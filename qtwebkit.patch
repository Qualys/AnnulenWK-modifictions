diff -Naur qtwebkit-5.212.0-alpha2/Source/cmake/OptionsCommon.cmake qtwebkit/Source/cmake/OptionsCommon.cmake
--- qtwebkit-5.212.0-alpha2/Source/cmake/OptionsCommon.cmake	2017-06-15 04:56:11.000000000 -0700
+++ qtwebkit/Source/cmake/OptionsCommon.cmake	2018-06-28 06:51:17.977206000 -0700
@@ -32,10 +32,6 @@
     set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fno-exceptions -fno-strict-aliasing")
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-exceptions -fno-strict-aliasing -fno-rtti")
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
-    if (NOT (COMPILER_IS_CLANG AND "${CLANG_VERSION}" VERSION_LESS 4.0.0))
-        set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wno-expansion-to-defined")
-        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-expansion-to-defined")
-    endif ()
 endif ()
 
 if (COMPILER_IS_CLANG AND CMAKE_GENERATOR STREQUAL "Ninja")
diff -Naur qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/API/JSBase.cpp qtwebkit/Source/JavaScriptCore/API/JSBase.cpp
--- qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/API/JSBase.cpp	2017-06-04 13:16:05.000000000 -0700
+++ qtwebkit/Source/JavaScriptCore/API/JSBase.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -24,6 +24,8 @@
  */
 
 #include "config.h"
+
+#define __IN_WEBKIT__
 #include "JSBase.h"
 #include "JSBasePrivate.h"
 
@@ -40,6 +42,9 @@
 #include "JSCInlines.h"
 #include "SourceCode.h"
 #include <wtf/text/StringHash.h>
+#include <wtf/text/WTFString.h>
+#include <iostream>
+#define GUID_STR "449241541"
 
 #if ENABLE(REMOTE_INSPECTOR)
 #include "JSGlobalObjectInspectorController.h"
@@ -189,3 +194,59 @@
 const char iosInstallName60 = 0;
 const char iosInstallName61 = 0;
 #endif
+
+void cTaintLog::add_taint_log(const char* code, const char* loc, unsigned int taint, unsigned int id, unsigned int pid, bool sink)
+{ 
+    if(!DOM_XSS_enabled)
+          return;
+
+      int int_code = atoi(code);
+        add_taint_log(int_code, loc, taint, id, pid, sink);
+}
+
+void cTaintLog::add_taint_log(int code, const char* loc, unsigned int taint, unsigned int id, unsigned int pid, bool sink )
+{ 
+  if(code <0 || code >9)
+    return;
+
+  if(taint == 0)
+    return;
+
+  log_elem logItem(taint, id, pid, loc, sink);
+  m_taintLogMap[code].insert( std::pair < unsigned int , log_elem > (id, logItem));
+  // not loggin those pahts that don't propogate the tiant at all
+  //std::cout << std::endl << "code" << code;
+  //std::cout << std::endl << "loc" << loc;
+  //std::cout << std::endl << "taint" << taint;
+  //std::cout << std::endl << "id" << id;
+  //std::cout << std::endl << "pid" << pid;
+  //std::cout << std::endl << "sink" << sink << std::endl  << std::endl ; 
+
+  if(sink && taint!=0)
+    m_source_met_sink[code] = true;
+}
+
+bool cTaintLog::getLogForCode(int code, log_elem_list_t &list)
+{ 
+  if(!m_source_met_sink[code])
+    return false;
+  log_map_t::iterator it;
+  it = m_taintLogMap.find(code);
+  if(it!=m_taintLogMap.end()) {
+    list = it->second;
+    return true;
+  }
+  else
+    return false;
+}
+
+bool cTaintLog::DOM_XSS_enabled= false;
+bool cTaintLog::DOM_XSS_Exploit_enabled = false;
+log_map_t cTaintLog::m_taintLogMap;
+source_met_sink_t cTaintLog::m_source_met_sink;
+std::string cTaintLog::sent_headers;
+std::string cTaintLog::sent_cookies;
+std::string cTaintLog::sent_body;
+std::string cTaintLog::rcv_body;
+std::string cTaintLog::rcv_headers;
+std::string cTaintLog::rcv_cookies;
diff -Naur qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/API/JSBase.h qtwebkit/Source/JavaScriptCore/API/JSBase.h
--- qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/API/JSBase.h	2017-06-04 13:16:05.000000000 -0700
+++ qtwebkit/Source/JavaScriptCore/API/JSBase.h	2018-06-28 06:51:17.977206000 -0700
@@ -25,6 +25,16 @@
 
 #ifndef JSBase_h
 #define JSBase_h
+#include <string>
+#include <map>
+#include <list>
+#include <vector>
+
+#define NUMBER_OF_SOURCES 9
+
+#ifdef __IN_WEBKIT__
+#include <WTF/wtf/Forward.h>
+#endif
 
 #ifndef __cplusplus
 #include <stdbool.h>
@@ -134,6 +144,86 @@
 }
 #endif
 
+class log_elem {
+  public:
+    log_elem()
+     : taint(0)
+       ,id(0)
+       ,pid(0)
+       ,sink()
+  {
+  }
+
+    log_elem(unsigned int t, unsigned int a_id, unsigned int a_pid, std::string l, bool s)
+     : taint(t)
+       ,id(a_id)
+       ,pid(a_pid)
+       ,loc(l)
+       ,sink(s)
+  {
+  }
+    unsigned int taint;
+    unsigned int id;
+    unsigned int pid;
+    std::string loc;
+    bool sink;
+};
+
+typedef std::map<unsigned int, log_elem> log_elem_list_t;
+typedef std::map <int, log_elem_list_t> log_map_t;
+typedef std::vector<bool> source_met_sink_t;
+
+enum source
+{ 
+  eSourceTypeNone,
+  eSourceTypeDocumentUrl,
+  eSourceTypeReferer,
+  eSourceTypeCookie,
+  eSourceTypeLocation
+};
+
+class cTaintLog
+{ 
+  public:
+    JS_EXPORT static bool getLogForCode(int code, log_elem_list_t &list);
+    JS_EXPORT static void resetTheLog() { m_taintLogMap.clear();  m_source_met_sink.assign(NUMBER_OF_SOURCES+1, false); }
+    JS_EXPORT static void setDOM_XSS(bool enable) { DOM_XSS_enabled = enable; }
+    JS_EXPORT static bool isDOM_XSS() { return DOM_XSS_enabled; }
+    JS_EXPORT static void setDOM_XSS_Exploit(bool enable) { DOM_XSS_Exploit_enabled = enable; }
+    JS_EXPORT static bool isDOM_XSS_Exploit() { return DOM_XSS_Exploit_enabled; }                                                                  JS_EXPORT static void add_taint_log(const char* code, const char* loc, unsigned int taint, unsigned int id, unsigned int pid, bool sink = false);
+    JS_EXPORT static void log_sent_headers(const char * str) { sent_headers = str; }
+    JS_EXPORT static void log_sent_cookies(const char * str) { sent_cookies = str; }
+    JS_EXPORT static void log_sent_body(const char * str) { sent_body = str; }
+    JS_EXPORT static void log_rcv_body(const char * str) { rcv_body = str; }
+    JS_EXPORT static void log_rcv_headers(const char * str) { rcv_headers = str; }
+    JS_EXPORT static void log_rcv_cookies(const char * str) { rcv_cookies = str; }
+
+    JS_EXPORT static void get_sent_headers(std::string &head) { head = sent_headers; }
+    JS_EXPORT static void get_sent_cookies(std::string &cookies) { cookies = sent_cookies; }
+    JS_EXPORT static void get_sent_body(std::string &body) { body = sent_body; }
+    JS_EXPORT static void get_rcv_body(std::string &body) { body = rcv_body; }
+    JS_EXPORT static void get_rcv_headers(std::string &head) { head = rcv_headers; }
+    JS_EXPORT static void get_rcv_cookies(std::string &cookies) { cookies = rcv_cookies; }
+
+
+    JS_EXPORT static void add_taint_log(int code, const char* loc, unsigned int taint, unsigned int id, unsigned int pid, bool sink = false);
+
+  private:
+    JS_EXPORT static bool DOM_XSS_enabled;
+    JS_EXPORT static bool DOM_XSS_Exploit_enabled;
+    JS_EXPORT static log_map_t m_taintLogMap;
+    JS_EXPORT static source_met_sink_t m_source_met_sink;
+
+    JS_EXPORT static std::string sent_headers,
+              sent_cookies,
+              sent_body,
+              rcv_body,
+              rcv_headers,
+              rcv_cookies;
+
+
+};
+
 /* Enable the Objective-C API for platforms with a modern runtime. */
 #if !defined(JSC_OBJC_API_ENABLED)
 #define JSC_OBJC_API_ENABLED (defined(__clang__) && defined(__APPLE__) && ((defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && !defined(__i386__)) || (defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE)))
diff -Naur qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/interpreter/Interpreter.cpp qtwebkit/Source/JavaScriptCore/interpreter/Interpreter.cpp
--- qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/interpreter/Interpreter.cpp	2017-06-04 13:16:05.000000000 -0700
+++ qtwebkit/Source/JavaScriptCore/interpreter/Interpreter.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -189,6 +189,18 @@
 
     JSValue thisValue = callerFrame->thisValue();
     Interpreter* interpreter = callFrame->vm().interpreter;
+
+    JSString* strPtr = asString(program);// program.toString(callFrame);
+
+    if(strPtr) {
+      const String &code  = strPtr->tryGetValue();
+      //program.toString(callFrame)->taint(callFrame) = 100;
+      //std::cout << "interpreter->execute "  << code.ascii().data() << std::endl;
+      //std::cout << "taint " << strPtr->taint() << std::endl;
+      //std::cout  << "parent ID" << strPtr->id() << std::endl;
+      cTaintLog::add_taint_log(strPtr->__dxx_source(), "eval", strPtr->__dxx_taint(), 0, strPtr->__dxx_id(), true);
+    }
+
     return interpreter->execute(eval, callFrame, thisValue, callerScopeChain);
 }
 
diff -Naur qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/parser/Parser.cpp qtwebkit/Source/JavaScriptCore/parser/Parser.cpp
--- qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/parser/Parser.cpp	2017-06-04 13:16:05.000000000 -0700
+++ qtwebkit/Source/JavaScriptCore/parser/Parser.cpp	2018-10-31 00:32:18.384369000 -0700
@@ -1089,6 +1089,8 @@
     JSTokenLocation location(tokenLocation());
     int startLine = tokenLine();
     next();
+    DepthManager statementDepth(&m_statementDepth);
+    m_statementDepth++;
     handleProductionOrFail(OPENPAREN, "(", "start", "for-loop header");
     int nonLHSCount = m_parserState.nonLHSCount;
     int declarations = 0;
@@ -1607,7 +1609,8 @@
         result = parseVariableDeclaration(context, DeclarationType::VarDeclaration);
         break;
     case FUNCTION:
-        failIfFalseIfStrict(m_statementDepth == 1, "Strict mode does not allow function declarations in a lexically nested statement");
36593077+        //failIfFalseIfStrict(m_statementDepth == 1, "Strict mode does not allow function declarations in a lexically nested statement");
         result = parseFunctionDeclaration(context);
         break;
     case SEMICOLON: {
diff -Naur qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/runtime/CallData.cpp qtwebkit/Source/JavaScriptCore/runtime/CallData.cpp
--- qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/runtime/CallData.cpp	2017-06-04 13:16:05.000000000 -0700
+++ qtwebkit/Source/JavaScriptCore/runtime/CallData.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -30,6 +30,8 @@
 #include "Interpreter.h"
 #include "JSCInlines.h"
 #include "JSFunction.h"
+#include <iostream>
+#include <API/JSBase.h>
 #include "ScriptProfilingScope.h"
 
 namespace JSC {
@@ -37,6 +39,16 @@
 JSValue call(ExecState* exec, JSValue functionObject, CallType callType, const CallData& callData, JSValue thisValue, const ArgList& args)
 {
     ASSERT(callType == CallTypeJS || callType == CallTypeHost);
+    
+    if(cTaintLog::isDOM_XSS()) {
+      //std::cout << "eval JSValue call"  << std::endl;
+      JSString *str = 0;// functionObject.toString(exec);
+      if(str) {
+        const String& s = str->value(exec);
+        //std::cout << "eval: " << s.ascii().data()  << std::endl;
+      }
+    }
+
     return exec->interpreter()->executeCall(exec, asObject(functionObject), callType, callData, thisValue, args);
 }
 
diff -Naur qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp qtwebkit/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp
--- qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp	2017-06-04 13:16:05.000000000 -0700
+++ qtwebkit/Source/JavaScriptCore/runtime/JSGlobalObjectFunctions.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -22,6 +22,8 @@
  *
  */
 
+#define __IN_WEBKIT__
+
 #include "config.h"
 #include "JSGlobalObjectFunctions.h"
 
@@ -48,6 +50,11 @@
 #include <wtf/text/StringBuilder.h>
 #include <wtf/unicode/UTF8.h>
 
+#include <iostream>
+#include <API/JSBase.h>
+#define GUID_STR "449241541"
+
+
 using namespace WTF;
 using namespace Unicode;
 
@@ -645,15 +652,48 @@
 EncodedJSValue JSC_HOST_CALL globalFuncDecodeURI(ExecState* exec)
 {
     static Bitmap<256> doNotUnescapeWhenDecodingURI = makeCharacterBitmap(
-        "#$&+,/:;=?@"
-    );
+     "#$&+,/:;=?@"
+     );
+
+    if(cTaintLog::isDOM_XSS()) {
+      JSValue v = decode(exec, doNotUnescapeWhenDecodingURI, true);
+      JSString* s = v.toString(exec);
+      JSString* a_str = exec->argument(0).toString(exec);
+
+      s->__dxx_taint(exec) = a_str->__dxx_taint(exec);
+      unsigned int id = rand();
+      s->__dxx_id(exec) = a_str->__dxx_id(exec);
+      s->__dxx_source(exec) = a_str->__dxx_source(exec);
 
-    return JSValue::encode(decode(exec, doNotUnescapeWhenDecodingURI, true));
+      cTaintLog::add_taint_log(a_str->__dxx_source(exec), "decodeURI", a_str->__dxx_taint(exec), id, a_str->__dxx_id(exec), false);
+      return  JSValue::encode(s);
+    }
+
+    else
+      return JSValue::encode(decode(exec, doNotUnescapeWhenDecodingURI, true));
 }
 
 EncodedJSValue JSC_HOST_CALL globalFuncDecodeURIComponent(ExecState* exec)
 {
-    static Bitmap<256> emptyBitmap;
+  static Bitmap<256> emptyBitmap;
+  if(cTaintLog::isDOM_XSS()) {
+    JSValue v = decode(exec, emptyBitmap, true);
+    JSString* s = v.toString(exec);
+    JSString* a_str = exec->argument(0).toString(exec);
+
+    s->__dxx_taint(exec) = a_str->__dxx_taint(exec);
+    unsigned int id = rand();
+    s->__dxx_id(exec) = a_str->__dxx_id(exec);
+    s->__dxx_source(exec) = a_str->__dxx_source(exec);
+
+    //std::cout << "ParentId: " <<  a_str->__dxx_id(exec) << "Id: " << id  <<  std::endl;
+    //std::cout << "setting taint for: " << "decodeURIComponent" << " taint%: " << a_str->__dxx_taint(exec) ;
+
+    cTaintLog::add_taint_log(a_str->__dxx_source(exec), "decodeURIComponent", a_str->__dxx_taint(exec), id, a_str->__dxx_id(exec), false);
+    return  JSValue::encode(s);
+  }
+
+  else
     return JSValue::encode(decode(exec, emptyBitmap, true));
 }
 
@@ -774,7 +814,20 @@
         }
     }
 
-    return JSValue::encode(jsString(exec, builder.toString()));
+    if(cTaintLog::isDOM_XSS()) {
+      JSString* s = jsString(exec, builder.toString());
+      JSString* a_str = exec->argument(0).toString(exec);
+      s->__dxx_taint(exec) = a_str->__dxx_taint(exec);
+      unsigned int id = rand();
+      s->__dxx_id(exec) = id;
+      s->__dxx_source(exec) = a_str->__dxx_source(exec);
+
+
+      cTaintLog::add_taint_log(a_str->__dxx_source(exec), "unescape", a_str->__dxx_taint(exec), id, a_str->__dxx_id(exec), false);
+      return JSValue::encode(s);
+    }
+    else
+      return JSValue::encode(jsString(exec, builder.toString()));
 }
 
 EncodedJSValue JSC_HOST_CALL globalFuncThrowTypeError(ExecState* exec)
diff -Naur qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/runtime/JSString.h qtwebkit/Source/JavaScriptCore/runtime/JSString.h
--- qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/runtime/JSString.h	2017-06-04 13:16:05.000000000 -0700
+++ qtwebkit/Source/JavaScriptCore/runtime/JSString.h	2018-06-28 06:51:17.977206000 -0700
@@ -6,7 +6,7 @@
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Library General Public
  *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
+ *  version 3 of the License, or (at your option) any later version.
  *
  *  This library is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -31,6 +31,8 @@
 #include "Structure.h"
 #include <array>
 #include <wtf/text/StringView.h>
+#include <iostream>
+
 
 namespace JSC {
 
@@ -91,6 +93,10 @@
     JSString(VM& vm, PassRefPtr<StringImpl> value)
         : JSCell(vm, vm.stringStructure.get())
         , m_flags(0)
+        //DOM_XSS
+        , m_tainted(0)
+        , m_id(0)
+        , m_source(0)
         , m_value(value)
     {
     }
@@ -98,6 +104,11 @@
     JSString(VM& vm)
         : JSCell(vm, vm.stringStructure.get())
         , m_flags(0)
+        //DOM_XSS
+        , m_tainted(0)
+        , m_id(0)
+        , m_source(0)
+ 
     {
     }
 
@@ -155,6 +166,13 @@
     StringViewWithUnderlyingString viewWithUnderlyingString(ExecState&) const;
 
     const String& value(ExecState*) const;
+    unsigned int&  __dxx_taint(ExecState* exec) ;
+    unsigned int&  __dxx_taint() { return m_tainted; }
+    unsigned int&  __dxx_id(ExecState* exec) ;
+    unsigned int&  __dxx_id() { return m_id; }
+  
+    char& __dxx_source(ExecState* exec) ;
+    char& __dxx_source() { return m_source; }
     const String& tryGetValue() const;
     const StringImpl* tryGetValueImpl() const;
     unsigned length() const { return m_length; }
@@ -206,6 +224,12 @@
 
     // A string is represented either by a String or a rope of fibers.
     unsigned m_length;
+
+    //DOM_XSS
+    mutable unsigned int  m_tainted;
+    mutable unsigned int  m_id;
+    mutable char          m_source;
+
     mutable String m_value;
 
 private:
@@ -275,6 +299,16 @@
     {
         Base::finishCreation(vm);
         m_length = s1->length() + s2->length();
+        if(s1->__dxx_taint()) {
+          m_tainted = s1->__dxx_taint();
+          m_id = s1->__dxx_id();
+          m_source = s1->__dxx_source();
+        }
+        else {
+          m_tainted = s2->__dxx_taint();
+          m_id = s2->__dxx_id();
+          m_source = s2->__dxx_source();
+        }
         setIs8Bit(s1->is8Bit() && s2->is8Bit());
         setIsSubstring(false);
         fiber(0).set(vm, this, s1);
@@ -284,8 +318,23 @@
 
     void finishCreation(VM& vm, JSString* s1, JSString* s2, JSString* s3)
     {
-        Base::finishCreation(vm);
-        m_length = s1->length() + s2->length() + s3->length();
+      Base::finishCreation(vm);
+      if(s1->__dxx_taint()) {  
+        m_tainted = s1->__dxx_taint();
+        m_id = s1->__dxx_id(); 
+        m_source = s1->__dxx_source();
+      }
+      else if(s2->__dxx_taint()) {
+        m_tainted = s2->__dxx_taint();
+        m_id = s2->__dxx_id();
+        m_source = s2->__dxx_source();
+      }
+      else {
+        m_tainted = s3->__dxx_taint();
+        m_id = s3->__dxx_id();
+        m_source = s3->__dxx_source();
+      }
+      m_length = s1->length() + s2->length() + s3->length();
         setIs8Bit(s1->is8Bit() && s2->is8Bit() &&  s3->is8Bit());
         setIsSubstring(false);
         fiber(0).set(vm, this, s1);
@@ -329,7 +378,12 @@
 
     void append(VM& vm, size_t index, JSString* jsString)
     {
-        fiber(index).set(vm, this, jsString);
+      if(jsString->__dxx_taint() && !m_tainted) {
+        m_tainted = jsString->__dxx_taint();
+        m_id = jsString->__dxx_id();
+        m_source = jsString->__dxx_source();
+      }
+      fiber(index).set(vm, this, jsString);
         m_length += jsString->m_length;
         RELEASE_ASSERT(static_cast<int32_t>(m_length) >= 0);
         setIs8Bit(is8Bit() && jsString->is8Bit());
@@ -509,6 +563,29 @@
     return AtomicStringImpl::lookUp(m_value.impl());
 }
 
+
+inline unsigned int& JSString::__dxx_taint(ExecState* exec) 
+{
+  if (isRope())
+    static_cast<const JSRopeString*>(this)->resolveRope(exec);
+  return m_tainted;
+}
+
+inline unsigned int& JSString::__dxx_id(ExecState* exec) 
+{
+  if (isRope())
+    static_cast<const JSRopeString*>(this)->resolveRope(exec);
+  return m_id;
+}
+
+inline char& JSString::__dxx_source(ExecState* exec) 
+{
+  if (isRope())
+    static_cast<const JSRopeString*>(this)->resolveRope(exec);
+  return m_source;
+}
+
+
 inline const String& JSString::value(ExecState* exec) const
 {
     if (isRope())
diff -Naur qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/runtime/StringPrototype.cpp qtwebkit/Source/JavaScriptCore/runtime/StringPrototype.cpp
--- qtwebkit-5.212.0-alpha2/Source/JavaScriptCore/runtime/StringPrototype.cpp	2017-06-04 13:16:05.000000000 -0700
+++ qtwebkit/Source/JavaScriptCore/runtime/StringPrototype.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -20,6 +20,8 @@
  *
  */
 
+#define __IN_WEBKIT__
+
 #include "config.h"
 #include "StringPrototype.h"
 
@@ -51,6 +53,9 @@
 #include <wtf/MathExtras.h>
 #include <wtf/text/StringView.h>
 #include <wtf/unicode/Collator.h>
+#include <API/JSBase.h>
+#include <iostream>
+#define GUID_STR "449241541"
 
 using namespace WTF;
 
@@ -65,6 +70,13 @@
 EncodedJSValue JSC_HOST_CALL stringProtoFuncConcat(ExecState*);
 EncodedJSValue JSC_HOST_CALL stringProtoFuncIndexOf(ExecState*);
 EncodedJSValue JSC_HOST_CALL stringProtoFuncLastIndexOf(ExecState*);
+
+EncodedJSValue JSC_HOST_CALL stringProtoFuncTaint(ExecState*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSetTaint(ExecState*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSource(ExecState*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncId(ExecState*);
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSetSource(ExecState*);
+
 EncodedJSValue JSC_HOST_CALL stringProtoFuncMatch(ExecState*);
 EncodedJSValue JSC_HOST_CALL stringProtoFuncRepeat(ExecState*);
 EncodedJSValue JSC_HOST_CALL stringProtoFuncReplace(ExecState*);
@@ -133,6 +145,14 @@
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("concat", stringProtoFuncConcat, DontEnum, 1);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("indexOf", stringProtoFuncIndexOf, DontEnum, 1);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("lastIndexOf", stringProtoFuncLastIndexOf, DontEnum, 1);
+
+    JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("__dxx_taint", stringProtoFuncTaint, DontEnum, 0);
+    JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("__dxx_setTaint", stringProtoFuncSetTaint, DontEnum, 1);
+    JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("__dxx_source", stringProtoFuncSource, DontEnum, 0);
+    JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("__dxx_setSource", stringProtoFuncSetSource, DontEnum, 1);
+    JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("__dxx_id", stringProtoFuncId, DontEnum, 0);
+
+
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("match", stringProtoFuncMatch, DontEnum, 1);
     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION("repeat", stringProtoFuncRepeat, DontEnum, 1);
     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION("replace", stringProtoFuncReplace, DontEnum, 2, StringPrototypeReplaceIntrinsic);
@@ -197,12 +217,45 @@
 // Helper for producing a JSString for 'string', where 'string' was been produced by
 // calling ToString on 'originalValue'. In cases where 'originalValue' already was a
 // string primitive we can just use this, otherwise we need to allocate a new JSString.
+
+void logAndForwardTaint(ExecState* exec, char * funcName, float propagationPercent)
+{
+  if(!cTaintLog::isDOM_XSS())
+    return;
+
+  JSValue thisValue = exec->thisValue();
+  JSString* sVal = thisValue.toString(exec);
+  if(sVal->__dxx_source(exec) == 0) 
+    return;
+
+  unsigned int dd = sVal->__dxx_taint(exec);
+  unsigned int parentId = sVal->__dxx_id(exec);
+  unsigned int id = rand();
+
+  //dd = dd * propagationPercent;
+  dd= ((float)dd)*.9999;
+  if(dd == 0)
+    return;
+
+  //TODO log id and parent ID
+  cTaintLog::add_taint_log(sVal->__dxx_source(exec), funcName, dd, id, parentId, false);
+  sVal->__dxx_taint(exec)= static_cast<unsigned int>(dd);
+  sVal->__dxx_id(exec) = id; 
+
+
+  //std::cout << "ParentId: " << parentId << "Id: " << id  <<  std::endl;
+  //std::cout << "setting taint for: " <<  funcName << " taint%: " << dd ;
+  //std::cout << " source: " << (int)(sVal->__dxx_source(exec)) << std::endl;
+
+}
+
 static inline JSString* jsStringWithReuse(ExecState* exec, JSValue originalValue, const String& string)
 {
     if (originalValue.isString()) {
         ASSERT(asString(originalValue)->value(exec) == string);
         return asString(originalValue);
     }
+  
     return jsString(exec, string);
 }
 
@@ -838,6 +891,17 @@
     JSString* string = thisValue.toString(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+
+    //DOM_XSS taint propogation
+    JSString* sVal = searchValue.toString(exec);
+    //detectTaintFromStr(sVal->__dxx_taint(exec), sVal->value(exec));
+    //std::cerr << "JSString::replace" << std::endl;
+    unsigned int id = rand();
+    cTaintLog::add_taint_log(sVal->__dxx_source(exec), "replace", sVal->__dxx_taint(exec), id, sVal->__dxx_id(exec),  false);
+    unsigned int dd = sVal->__dxx_taint(exec);
+    string->__dxx_taint(exec)= static_cast<unsigned int>(dd);
+    // end DOM_XSS taint 
+
     return replace(exec, string, searchValue, replaceValue);
 }
 
@@ -860,6 +924,8 @@
     JSValue thisValue = exec->thisValue();
     // Also used for valueOf.
 
+    //logAndForwardTaint(exec, "toString", 1);
+
     if (thisValue.isString())
         return JSValue::encode(thisValue);
 
@@ -949,6 +1015,9 @@
     if (thisValue.isString() && exec->argumentCount() == 1)
         return JSValue::encode(jsString(exec, asString(thisValue), exec->uncheckedArgument(0).toString(exec)));
 
+    //DOM XSS the (this) string is propagating by 100%, no matter what the taing propagation % is for the argument string 
+    logAndForwardTaint(exec, "concat", 1);
+
     if (!checkObjectCoercible(thisValue))
         return throwVMTypeError(exec);
     return JSValue::encode(jsStringFromArguments(exec, thisValue));
@@ -1039,6 +1108,9 @@
 
     JSValue a0 = exec->argument(0);
 
+   //DOM XSS assuming very low likelyhood of long resulting string
+   logAndForwardTaint(exec, "match", 0.1);
+
     RegExp* regExp;
     bool global = false;
     if (a0.inherits(RegExpObject::info())) {
@@ -1125,6 +1197,14 @@
             from = 0;
         if (to > len)
             to = len;
+
+        //DOM XSS taint handling
+        float taintPcnt = .0;
+        int substringLen =  static_cast<unsigned>(to) - static_cast<unsigned>(from); 
+        if(substringLen && len)
+          taintPcnt= substringLen/len;
+        logAndForwardTaint(exec, "slice", taintPcnt);
+
         return JSValue::encode(jsSubstring(exec, s, static_cast<unsigned>(from), static_cast<unsigned>(to) - static_cast<unsigned>(from)));
     }
 
@@ -1189,6 +1269,9 @@
     // 7. Let p = 0.
     size_t position = 0;
 
+    //DOM_XSS taint propogation
+        logAndForwardTaint(exec, "split", .77);
+
     // 8. If separator is a RegExp object (its [[Class]] is "RegExp"), let R = separator;
     //    otherwise let R = ToString(separator).
     JSValue separatorValue = exec->argument(0);
@@ -1204,8 +1287,17 @@
         if (separatorValue.isUndefined()) {
             // a. Call the [[DefineOwnProperty]] internal method of A with arguments "0",
             //    Property Descriptor {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
+          if(cTaintLog::isDOM_XSS()) {
+            JSString* s = jsStringWithReuse(exec, thisValue, input);
+            JSString* sVal = thisValue.toString(exec);
+            s->__dxx_taint(exec) = sVal->__dxx_taint(exec); 
+            s->__dxx_source(exec) = sVal->__dxx_source(exec); 
+            s->__dxx_id(exec) = sVal->__dxx_id(exec);
+            result->putDirectIndex(exec, 0, s);
+          }
+          else
             result->putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
-            // b. Return A.
+          // b. Return A.
             return JSValue::encode(result);
         }
 
@@ -1216,9 +1308,20 @@
             // c. Call the [[DefineOwnProperty]] internal method of A with arguments "0",
             //    Property Descriptor {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
             // d. Return A.
-            if (!reg->match(*vm, input, 0))
-                result->putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
-            return JSValue::encode(result);
+          if (!reg->match(*vm, input, 0)) {
+            if(cTaintLog::isDOM_XSS()) {
+              JSString* s = jsStringWithReuse(exec, thisValue, input);
+              JSString* sVal = thisValue.toString(exec);
+              s->__dxx_taint(exec) = sVal->__dxx_taint(exec);
+              s->__dxx_source(exec) = sVal->__dxx_source(exec);
+              s->__dxx_id(exec) = sVal->__dxx_id(exec);
+              result->putDirectIndex(exec, 0, s);
+            }
+            else
+              result->putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
+          }
+
+          return JSValue::encode(result);
         }
 
         // 12. Let q = p.
@@ -1256,7 +1359,17 @@
             //    through q (exclusive).
             // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
             //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
-            result->putDirectIndex(exec, resultLength, jsSubstring(exec, thisValue, input, position, matchPosition - position));
+            if(cTaintLog::isDOM_XSS()) {
+              JSString* s = jsSubstring(exec, input, position, matchPosition - position);  
+              JSString* sVal = thisValue.toString(exec);
+              s->__dxx_taint(exec) = sVal->__dxx_taint(exec);
+              s->__dxx_source(exec) = sVal->__dxx_source(exec);
+              s->__dxx_id(exec) = sVal->__dxx_id(exec);
+              result->putDirectIndex(exec, resultLength, s);
+            }
+            else
+              result->putDirectIndex(exec, resultLength, jsSubstring(exec, thisValue, input, position, matchPosition - position));
+
 
             // 3. Increment lengthA by 1.
             // 4. If lengthA == lim, return A.
@@ -1291,7 +1404,18 @@
                 //   ToString(lengthA), Property Descriptor {[[Value]]: cap[i], [[Writable]]:
                 //   true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
                 int sub = ovector[i * 2];
-                result->putDirectIndex(exec, resultLength, sub < 0 ? jsUndefined() : jsSubstring(exec, thisValue, input, sub, ovector[i * 2 + 1] - sub));
+                
+                if(cTaintLog::isDOM_XSS()) {
+                  JSString* s = jsSubstring(exec, input, position, matchPosition - position);  
+                  JSString* sVal = thisValue.toString(exec);
+                  s->__dxx_taint(exec) = sVal->__dxx_taint(exec);
+                  s->__dxx_source(exec) = sVal->__dxx_source(exec);
+                  s->__dxx_id(exec) = sVal->__dxx_id(exec);
+                  result->putDirectIndex(exec, resultLength, s);
+                }
+                else
+                  result->putDirectIndex(exec, resultLength, sub < 0 ? jsUndefined() : jsSubstring(exec, thisValue, input, sub, ovector[i * 2 + 1] - sub)); 
+
                 // c Increment lengthA by 1.
                 // d If lengthA == lim, return A.
                 if (++resultLength == limit)
@@ -1312,9 +1436,20 @@
         if (separatorValue.isUndefined()) {
             // a.  Call the [[DefineOwnProperty]] internal method of A with arguments "0",
             //     Property Descriptor {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
+
+          if(cTaintLog::isDOM_XSS()) {
+            JSString* s = jsStringWithReuse(exec, thisValue, input);
+            JSString* sVal = thisValue.toString(exec);
+            s->__dxx_taint(exec) = sVal->__dxx_taint(exec);
+            s->__dxx_source(exec) = sVal->__dxx_source(exec);
+            s->__dxx_id(exec) = sVal->__dxx_id(exec);
+            result->putDirectIndex(exec, 0, s);
+          }
+          else
             result->putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
-            // b.  Return A.
-            return JSValue::encode(result);
+
+          // b.  Return A.
+          return JSValue::encode(result);
         }
 
         // 11. If s == 0, then
@@ -1324,9 +1459,21 @@
             // c. Call the [[DefineOwnProperty]] internal method of A with arguments "0",
             //    Property Descriptor {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
             // d. Return A.
-            if (!separator.isEmpty())
+
+            if (!separator.isEmpty()) {
+              if(cTaintLog::isDOM_XSS()) {
+                JSString* s = jsStringWithReuse(exec, thisValue, input);
+                JSString* sVal = thisValue.toString(exec);
+                s->__dxx_taint(exec) = sVal->__dxx_taint(exec);
+                s->__dxx_source(exec) = sVal->__dxx_source(exec);
+                s->__dxx_id(exec) = sVal->__dxx_id(exec);
+                result->putDirectIndex(exec, 0, s);
+              }
+              else
                 result->putDirectIndex(exec, 0, jsStringWithReuse(exec, thisValue, input));
+            }
             return JSValue::encode(result);
+
         }
 
         // Optimized case for splitting on the empty string.
@@ -1336,7 +1483,17 @@
             ASSERT(limit);
 
             do {
+              if(cTaintLog::isDOM_XSS()) {
+                JSString* s = jsSingleCharacterString(exec, input[position]);
+                JSString* sVal = thisValue.toString(exec);
+                s->__dxx_taint(exec) = sVal->__dxx_taint(exec);
+                s->__dxx_source(exec) = sVal->__dxx_source(exec);
+                s->__dxx_id(exec) = sVal->__dxx_id(exec);
+                result->putDirectIndex(exec, position, s);
+              }
+              else
                 result->putDirectIndex(exec, position, jsSingleCharacterString(exec, input[position]));
+
             } while (++position < limit);
 
             return JSValue::encode(result);
@@ -1376,6 +1533,16 @@
                 //    through q (exclusive).
                 // 2. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA),
                 //    Property Descriptor {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
+              if(cTaintLog::isDOM_XSS()) {
+                JSString* s = jsSubstring(exec, input, position, matchPosition - position);
+                JSString* sVal = thisValue.toString(exec);
+                s->__dxx_taint(exec) = sVal->__dxx_taint(exec);
+                s->__dxx_source(exec) = sVal->__dxx_source(exec);
+                s->__dxx_id(exec) = sVal->__dxx_id(exec);
+                result->putDirectIndex(exec, resultLength, s);
+
+              }
+              else
                 result->putDirectIndex(exec, resultLength, jsSubstring(exec, thisValue, input, position, matchPosition - position));
                 // 3. Increment lengthA by 1.
                 // 4. If lengthA == lim, return A.
@@ -1393,7 +1560,16 @@
     //     through s (exclusive).
     // 15. Call the [[DefineOwnProperty]] internal method of A with arguments ToString(lengthA), Property Descriptor
     //     {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and false.
-    result->putDirectIndex(exec, resultLength++, jsSubstring(exec, thisValue, input, position, input.length() - position));
+    if(cTaintLog::isDOM_XSS()) {
+      JSString* s = jsSubstring(exec, input, position, input.length() - position);
+      JSString* sVal = thisValue.toString(exec);
+      s->__dxx_taint(exec) = sVal->__dxx_taint(exec);
+      s->__dxx_source(exec) = sVal->__dxx_source(exec);
+      s->__dxx_id(exec) = sVal->__dxx_id(exec);
+      result->putDirectIndex(exec, resultLength++, s);
+    }
+    else
+      result->putDirectIndex(exec, resultLength++, jsSubstring(exec, thisValue, input, position, input.length() - position));
 
     // 16. Return A.
     return JSValue::encode(result);
@@ -1433,9 +1609,33 @@
         length = len - start;
     unsigned substringStart = static_cast<unsigned>(start);
     unsigned substringLength = static_cast<unsigned>(length);
-    if (jsString)
-        return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));
-    return JSValue::encode(jsSubstring(exec, uString, substringStart, substringLength));
+
+    //DOM XSS taint handling
+    float taintPcnt = .999;
+    //if(substringLength && len)
+    //  taintPcnt= .75;  substringLength/len;
+    logAndForwardTaint(exec, "substr", taintPcnt);
+
+    if (jsString) {
+      JSString* str = jsSubstring(exec, jsString, substringStart, substringLength);
+      if(cTaintLog::isDOM_XSS()) {
+        str->__dxx_taint(exec) = jsString->__dxx_taint(exec);
+        str->__dxx_source(exec) = jsString->__dxx_source(exec);
+        str->__dxx_id(exec) = jsString->__dxx_id(exec);
+      }
+      return JSValue::encode(str);
+
+    }
+
+    JSString* str = jsSubstring(exec,  uString, substringStart, substringLength);
+    /*  disabling because UString is not instrumented yet 
+        if(cTaintLog::isDOM_XSS()) {
+        str->__dxx_taint(exec) = uString->__dxx_taint(exec);
+        str->__dxx_source(exec) = uString->__dxx_source(exec);
+        str->__dxx_id(exec) = uString->__dxx_id(exec);
+        }
+        */
+    return JSValue::encode(str);
 }
 
 EncodedJSValue JSC_HOST_CALL stringProtoFuncSubstring(ExecState* exec)
@@ -1476,7 +1676,18 @@
     }
     unsigned substringStart = static_cast<unsigned>(start);
     unsigned substringLength = static_cast<unsigned>(end) - substringStart;
-    return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));
+
+    float taintPcnt = .75;
+    //if(substringLength && len)
+    //  taintPcnt= substringLength/len;
+    logAndForwardTaint(exec, "substring", taintPcnt);
+
+    //return JSValue::encode(jsSubstring(exec, jsString, substringStart, substringLength));
+    JSString* r = jsSubstring(exec, jsString, substringStart, substringLength);
+    r->__dxx_taint(exec) = jsString->__dxx_taint(exec); 
+    r->__dxx_source(exec) = jsString->__dxx_source(exec); 
+    r->__dxx_id(exec) = jsString->__dxx_id(exec);
+    return JSValue::encode(r);
 }
 
 EncodedJSValue JSC_HOST_CALL stringProtoFuncToLowerCase(ExecState* exec)
@@ -1486,12 +1697,91 @@
         return throwVMTypeError(exec);
     JSString* sVal = thisValue.toString(exec);
     const String& s = sVal->value(exec);
+
+    logAndForwardTaint(exec, "toLower", 0.99);
+
     String lowercasedString = s.convertToLowercaseWithoutLocale();
     if (lowercasedString.impl() == s.impl())
         return JSValue::encode(sVal);
     return JSValue::encode(jsString(exec, lowercasedString));
 }
 
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSetTaint(ExecState* exec)
+{
+  // std::cerr << "JSString::setTaint" << std::endl;
+  JSValue thisValue = exec->thisValue();
+  if (thisValue.isUndefinedOrNull()) // CheckObjectCoercible
+    return throwVMTypeError(exec);
+  JSString* sVal = thisValue.toString(exec);
+  const unsigned int  t = sVal->__dxx_taint(exec);
+  JSValue a0 = exec->argument(0);
+  double dd = a0.toInteger(exec);
+  sVal->__dxx_taint(exec) = static_cast<unsigned int>(dd);
+
+
+  size_t result = t;
+  return JSValue::encode(jsNumber(result));
+}
+
+EncodedJSValue JSC_HOST_CALL stringProtoFuncTaint(ExecState* exec)
+{
+  //std::cerr << "JSString::taint" << std::endl;
+  JSValue thisValue = exec->thisValue();
+  if (thisValue.isUndefinedOrNull()) // CheckObjectCoercible
+    return throwVMTypeError(exec);
+  JSString* sVal = thisValue.toString(exec);
+  const unsigned int  t = sVal->__dxx_taint(exec);
+
+  size_t result = t;
+  return JSValue::encode(jsNumber(result));
+}
+
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSetSource(ExecState* exec)
+{
+  //std::cerr << "JSString::setSource" << std::endl;
+  JSValue thisValue = exec->thisValue();
+  if (thisValue.isUndefinedOrNull()) // CheckObjectCoercible
+    return throwVMTypeError(exec);
+  JSString* sVal = thisValue.toString(exec);
+  const char t = sVal->__dxx_source(exec);
+  JSValue a0 = exec->argument(0);
+  double dd = a0.toInteger(exec);
+  sVal->__dxx_source(exec) = static_cast<char>(dd);
+
+
+  size_t result = t;
+
+  //std::cerr << "JSString::setSource END" << std::endl;
+  return JSValue::encode(jsNumber(result));
+}
+
+EncodedJSValue JSC_HOST_CALL stringProtoFuncId(ExecState* exec)
+{
+  //std::cerr << "JSString::source" << std::endl;
+  JSValue thisValue = exec->thisValue();
+  if (thisValue.isUndefinedOrNull()) // CheckObjectCoercible
+    return throwVMTypeError(exec);
+  JSString* sVal = thisValue.toString(exec);
+  const unsigned int   t = sVal->__dxx_id(exec);
+
+  size_t result = t;
+  return JSValue::encode(jsNumber(result));
+}
+
+EncodedJSValue JSC_HOST_CALL stringProtoFuncSource(ExecState* exec)
+{
+  //std::cerr << "JSString::source" << std::endl;
+  JSValue thisValue = exec->thisValue();
+  if (thisValue.isUndefinedOrNull()) // CheckObjectCoercible
+    return throwVMTypeError(exec);
+  JSString* sVal = thisValue.toString(exec);
+  const char  t = sVal->__dxx_source(exec);
+
+  size_t result = t;
+  //std::cerr << "JSString::source END" << std::endl;
+  return JSValue::encode(jsNumber(result));
+}
+
 EncodedJSValue JSC_HOST_CALL stringProtoFuncToUpperCase(ExecState* exec)
 {
     JSValue thisValue = exec->thisValue();
@@ -1499,6 +1789,10 @@
         return throwVMTypeError(exec);
     JSString* sVal = thisValue.toString(exec);
     const String& s = sVal->value(exec);
+
+    //DOM XSS
+    logAndForwardTaint(exec, "toUpperCase", 0.01);
+
     String uppercasedString = s.convertToUppercaseWithoutLocale();
     if (uppercasedString.impl() == s.impl())
         return JSValue::encode(sVal);
@@ -1628,6 +1922,9 @@
     String s = thisValue.toString(exec)->value(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+    
+    logAndForwardTaint(exec, "big", 1);
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<big>", s, "</big>"));
 }
 
@@ -1639,6 +1936,9 @@
     String s = thisValue.toString(exec)->value(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+
+    logAndForwardTaint(exec, "small", 1);
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<small>", s, "</small>"));
 }
 
@@ -1650,6 +1950,9 @@
     String s = thisValue.toString(exec)->value(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+
+    logAndForwardTaint(exec, "blink", 1);
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<blink>", s, "</blink>"));
 }
 
@@ -1661,6 +1964,9 @@
     String s = thisValue.toString(exec)->value(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+
+    logAndForwardTaint(exec, "bold", 1);
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<b>", s, "</b>"));
 }
 
@@ -1672,6 +1978,9 @@
     String s = thisValue.toString(exec)->value(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+
+    logAndForwardTaint(exec, "fixed", 1);
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<tt>", s, "</tt>"));
 }
 
@@ -1683,6 +1992,9 @@
     String s = thisValue.toString(exec)->value(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+
+    logAndForwardTaint(exec, "italics", 1);
+    
     return JSValue::encode(jsMakeNontrivialString(exec, "<i>", s, "</i>"));
 }
 
@@ -1694,6 +2006,9 @@
     String s = thisValue.toString(exec)->value(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+
+    logAndForwardTaint(exec, "strike", 1);
+    
     return JSValue::encode(jsMakeNontrivialString(exec, "<strike>", s, "</strike>"));
 }
 
@@ -1705,6 +2020,9 @@
     String s = thisValue.toString(exec)->value(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+
+    logAndForwardTaint(exec, "sub", 1);
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<sub>", s, "</sub>"));
 }
 
@@ -1716,6 +2034,9 @@
     String s = thisValue.toString(exec)->value(exec);
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
+
+    logAndForwardTaint(exec, "sup", 1);
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<sup>", s, "</sup>"));
 }
 
@@ -1732,6 +2053,8 @@
     String color = a0.toWTFString(exec);
     color.replaceWithLiteral('"', "&quot;");
 
+    logAndForwardTaint(exec, "fontcolor", 1);
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<font color=\"", color, "\">", s, "</font>"));
 }
 
@@ -1784,6 +2107,8 @@
     String fontSize = a0.toWTFString(exec);
     fontSize.replaceWithLiteral('"', "&quot;");
 
+    logAndForwardTaint(exec, "fontsize", 1);
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<font size=\"", fontSize, "\">", s, "</font>"));
 }
 
@@ -1800,6 +2125,8 @@
     String anchor = a0.toWTFString(exec);
     anchor.replaceWithLiteral('"', "&quot;");
 
+    logAndForwardTaint(exec, "anchor", 1); 
+
     return JSValue::encode(jsMakeNontrivialString(exec, "<a name=\"", anchor, "\">", s, "</a>"));
 }
 
@@ -1841,6 +2168,9 @@
     buffer[12 + linkTextSize + stringSize] = '/';
     buffer[13 + linkTextSize + stringSize] = 'a';
     buffer[14 + linkTextSize + stringSize] = '>';
+
+    logAndForwardTaint(exec, "link", 1);
+
     return JSValue::encode(jsNontrivialString(exec, impl));
 }
 
@@ -1878,18 +2208,27 @@
 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrim(ExecState* exec)
 {
     JSValue thisValue = exec->thisValue();
+
+    logAndForwardTaint(exec, "trim", .99);
+
     return JSValue::encode(trimString(exec, thisValue, TrimLeft | TrimRight));
 }
 
 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimLeft(ExecState* exec)
 {
     JSValue thisValue = exec->thisValue();
+
+    logAndForwardTaint(exec, "trimLeft", .99);
+
     return JSValue::encode(trimString(exec, thisValue, TrimLeft));
 }
 
 EncodedJSValue JSC_HOST_CALL stringProtoFuncTrimRight(ExecState* exec)
 {
     JSValue thisValue = exec->thisValue();
+    
+    logAndForwardTaint(exec, "trimRight", .99);
+
     return JSValue::encode(trimString(exec, thisValue, TrimRight));
 }
 
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/css/CSSValuePool.cpp qtwebkit/Source/WebCore/css/CSSValuePool.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/css/CSSValuePool.cpp	2017-06-04 13:16:06.000000000 -0700
+++ qtwebkit/Source/WebCore/css/CSSValuePool.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -126,6 +126,10 @@
         m_fontFamilyValueCache.remove(m_fontFamilyValueCache.begin());
 
     bool isFromSystemID = fromSystemFontID == FromSystemFontID::Yes;
+    
+    if(strlen(familyName.ascii().data()) == 0) {
+        return CSSPrimitiveValue::create(CSSFontFamily{"Arial", isFromSystemID});
+    }
     RefPtr<CSSPrimitiveValue>& value = m_fontFamilyValueCache.add({familyName, isFromSystemID}, nullptr).iterator->value;
     if (!value)
         value = CSSPrimitiveValue::create(CSSFontFamily{familyName, isFromSystemID});
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/dom_generated/JSDocument.cpp qtwebkit/Source/WebCore/dom_generated/JSDocument.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/dom_generated/JSDocument.cpp	1969-12-31 16:00:00.000000000 -0800
+++ qtwebkit/Source/WebCore/dom_generated/JSDocument.cpp	2018-04-30 14:47:23.452799000 -0700
@@ -0,0 +1,5011 @@
+/*
+    This file is part of the WebKit open source project.
+    This file has been generated by generate-bindings.pl. DO NOT MODIFY!
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "config.h"
+#include "JSDocument.h"
+
+#include "Attr.h"
+#include "CDATASection.h"
+#include "CSSStyleDeclaration.h"
+#include "CanvasRenderingContext.h"
+#include "Comment.h"
+#include "DOMImplementation.h"
+#include "DOMNamedFlowCollection.h"
+#include "DOMSelection.h"
+#include "DOMWindow.h"
+#include "DocumentFragment.h"
+#include "DocumentType.h"
+#include "Element.h"
+#include "Event.h"
+#include "ExceptionCode.h"
+#include "HTMLCollection.h"
+#include "HTMLElement.h"
+#include "HTMLHeadElement.h"
+#include "HTMLScriptElement.h"
+#include "JSAttr.h"
+#include "JSCDATASection.h"
+#include "JSCSSStyleDeclaration.h"
+#include "JSCanvasRenderingContext.h"
+#include "JSComment.h"
+#include "JSCustomXPathNSResolver.h"
+#include "JSDOMBinding.h"
+#include "JSDOMConstructor.h"
+#include "JSDOMImplementation.h"
+#include "JSDOMSelection.h"
+#include "JSDOMWindow.h"
+#include "JSDocumentFragment.h"
+#include "JSDocumentType.h"
+#include "JSElement.h"
+#include "JSEvent.h"
+#include "JSEventListener.h"
+#include "JSEventTarget.h"
+#include "JSHTMLCollection.h"
+#include "JSHTMLElement.h"
+#include "JSHTMLHeadElement.h"
+#include "JSHTMLScriptElement.h"
+#include "JSLocation.h"
+#include "JSNode.h"
+#include "JSNodeFilter.h"
+#include "JSNodeIterator.h"
+#include "JSNodeList.h"
+#include "JSProcessingInstruction.h"
+#include "JSRange.h"
+#include "JSStyleSheetList.h"
+#include "JSText.h"
+#include "JSTouch.h"
+#include "JSTreeWalker.h"
+#include "JSXPathExpression.h"
+#include "JSXPathNSResolver.h"
+#include "JSXPathResult.h"
+#include "Location.h"
+#include "NameNodeList.h"
+#include "Node.h"
+#include "NodeIterator.h"
+#include "NodeList.h"
+#include "ProcessingInstruction.h"
+#include "Range.h"
+#include "StyleProperties.h"
+#include "StyleSheetList.h"
+#include "Text.h"
+#include "Touch.h"
+#include "TreeWalker.h"
+#include "URL.h"
+#include "XPathExpression.h"
+#include "XPathNSResolver.h"
+#include "XPathResult.h"
+#include <runtime/Error.h>
+#include <runtime/JSString.h>
+#include <wtf/GetPtr.h>
+
+#if ENABLE(CSS_REGIONS)
+#include "JSDOMNamedFlowCollection.h"
+#endif
+
+#if ENABLE(FONT_LOAD_EVENTS)
+#include "FontLoader.h"
+#include "JSFontLoader.h"
+#endif
+
+using namespace JSC;
+
+namespace WebCore {
+
+// Functions
+
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateElement(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateDocumentFragment(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateTextNode(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateComment(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateCDATASection(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateProcessingInstruction(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateAttribute(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementsByTagName(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionImportNode(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateElementNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateAttributeNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementsByTagNameNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionAdoptNode(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateEvent(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateRange(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateNodeIterator(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateTreeWalker(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetOverrideStyle(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateExpression(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateNSResolver(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionEvaluate(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionExecCommand(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandEnabled(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandIndeterm(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandState(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandSupported(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandValue(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementsByName(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionElementFromPoint(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCaretRangeFromPoint(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetSelection(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetCSSCanvasContext(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementsByClassName(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionHasFocus(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionWebkitCancelFullScreen(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionWebkitExitFullscreen(JSC::ExecState*);
+#if ENABLE(POINTER_LOCK)
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionExitPointerLock(JSC::ExecState*);
+#endif
+#if ENABLE(CSS_REGIONS)
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionWebkitGetNamedFlows(JSC::ExecState*);
+#endif
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateTouch(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateTouchList(JSC::ExecState*);
+#if ENABLE(CUSTOM_ELEMENTS)
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionDefineCustomElement(JSC::ExecState*);
+#endif
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementById(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionPrepend(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionAppend(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQuerySelector(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQuerySelectorAll(JSC::ExecState*);
+
+// Attributes
+
+JSC::EncodedJSValue jsDocumentDoctype(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentImplementation(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentDocumentElement(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentInputEncoding(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentXMLEncoding(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentXMLVersion(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentXMLVersion(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentXMLStandalone(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentXMLStandalone(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentDocumentURI(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentDefaultView(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentStyleSheets(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentContentType(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentTitle(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentTitle(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentReferrer(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentDomain(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentDomain(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentURL(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentCookie(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentCookie(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+void setJSDocumentURL(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentBody(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentBody(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentHead(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentImages(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentApplets(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentLinks(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentForms(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentAnchors(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentLastModified(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentLocation(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentLocation(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentCharset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentDefaultCharset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentReadyState(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentCharacterSet(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentPreferredStylesheetSet(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentSelectedStylesheetSet(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentSelectedStylesheetSet(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentActiveElement(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentCompatMode(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentWebkitIsFullScreen(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentWebkitFullScreenKeyboardInputAllowed(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentWebkitCurrentFullScreenElement(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentWebkitFullscreenEnabled(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentWebkitFullscreenElement(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+#if ENABLE(POINTER_LOCK)
+JSC::EncodedJSValue jsDocumentPointerLockElement(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+#endif
+#if ENABLE(FONT_LOAD_EVENTS)
+JSC::EncodedJSValue jsDocumentFonts(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+#endif
+JSC::EncodedJSValue jsDocumentVisibilityState(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentHidden(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentCurrentScript(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentOrigin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentScrollingElement(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentOnbeforecopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnbeforecopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnbeforecut(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnbeforecut(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnbeforepaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnbeforepaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOncopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOncopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOncut(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOncut(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnpaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnpaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnselectstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnselectstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#if ENABLE(FULLSCREEN_API)
+JSC::EncodedJSValue jsDocumentOnwebkitfullscreenchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitfullscreenchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(FULLSCREEN_API)
+JSC::EncodedJSValue jsDocumentOnwebkitfullscreenerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitfullscreenerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsDocumentOnselectionchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnselectionchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnreadystatechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnreadystatechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#if ENABLE(CSP_NEXT)
+JSC::EncodedJSValue jsDocumentOnsecuritypolicyviolation(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnsecuritypolicyviolation(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(POINTER_LOCK)
+JSC::EncodedJSValue jsDocumentOnpointerlockchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnpointerlockchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(POINTER_LOCK)
+JSC::EncodedJSValue jsDocumentOnpointerlockerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnpointerlockerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsDocumentOnabort(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnabort(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+JSC::EncodedJSValue jsDocumentOnautocomplete(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnautocomplete(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+JSC::EncodedJSValue jsDocumentOnautocompleteerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnautocompleteerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsDocumentOnblur(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnblur(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOncanplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOncanplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOncanplaythrough(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOncanplaythrough(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOncontextmenu(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOncontextmenu(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOndblclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOndblclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOndrag(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOndrag(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOndragend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOndragend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOndragenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOndragenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOndragleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOndragleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOndragover(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOndragover(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOndragstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOndragstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOndrop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOndrop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOndurationchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOndurationchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnemptied(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnemptied(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnended(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnended(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnfocus(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnfocus(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOninput(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOninput(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOninvalid(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOninvalid(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnkeydown(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnkeydown(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnkeypress(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnkeypress(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnkeyup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnkeyup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnload(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnload(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnloadeddata(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnloadeddata(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnloadedmetadata(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnloadedmetadata(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnloadstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnloadstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnmousedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnmousedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnmouseenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnmouseenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnmouseleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnmouseleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnmousemove(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnmousemove(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnmouseout(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnmouseout(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnmouseover(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnmouseover(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnmouseup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnmouseup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnmousewheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnmousewheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnpause(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnpause(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnplaying(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnplaying(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnprogress(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnprogress(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnratechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnratechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnreset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnreset(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnresize(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnresize(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnscroll(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnscroll(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnseeked(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnseeked(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnseeking(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnseeking(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnselect(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnselect(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnstalled(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnstalled(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnsubmit(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnsubmit(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnsuspend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnsuspend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOntimeupdate(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOntimeupdate(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnvolumechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnvolumechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnwaiting(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwaiting(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnsearch(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnsearch(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsDocumentOnwheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#if ENABLE(TOUCH_EVENTS)
+JSC::EncodedJSValue jsDocumentOntouchcancel(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOntouchcancel(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(TOUCH_EVENTS)
+JSC::EncodedJSValue jsDocumentOntouchend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOntouchend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(TOUCH_EVENTS)
+JSC::EncodedJSValue jsDocumentOntouchmove(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOntouchmove(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(TOUCH_EVENTS)
+JSC::EncodedJSValue jsDocumentOntouchstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOntouchstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+JSC::EncodedJSValue jsDocumentOnwebkitmouseforcechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitmouseforcechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+JSC::EncodedJSValue jsDocumentOnwebkitmouseforcedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitmouseforcedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+JSC::EncodedJSValue jsDocumentOnwebkitmouseforcewillbegin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitmouseforcewillbegin(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+JSC::EncodedJSValue jsDocumentOnwebkitmouseforceup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitmouseforceup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+JSC::EncodedJSValue jsDocumentOnwebkitwillrevealbottom(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitwillrevealbottom(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+JSC::EncodedJSValue jsDocumentOnwebkitwillrevealleft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitwillrevealleft(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+JSC::EncodedJSValue jsDocumentOnwebkitwillrevealright(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitwillrevealright(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+JSC::EncodedJSValue jsDocumentOnwebkitwillrevealtop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentOnwebkitwillrevealtop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsDocumentChildren(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentFirstElementChild(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentLastElementChild(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentChildElementCount(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsDocumentConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSDocumentConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+
+class JSDocumentPrototype : public JSC::JSNonFinalObject {
+public:
+    typedef JSC::JSNonFinalObject Base;
+    static JSDocumentPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
+    {
+        JSDocumentPrototype* ptr = new (NotNull, JSC::allocateCell<JSDocumentPrototype>(vm.heap)) JSDocumentPrototype(vm, globalObject, structure);
+        ptr->finishCreation(vm);
+        return ptr;
+    }
+
+    DECLARE_INFO;
+    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
+    {
+        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
+    }
+
+private:
+    JSDocumentPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
+        : JSC::JSNonFinalObject(vm, structure)
+    {
+    }
+
+    void finishCreation(JSC::VM&);
+};
+
+typedef JSDOMConstructor<JSDocument> JSDocumentConstructor;
+
+/* Hash table */
+
+static const struct CompactHashIndex JSDocumentTableIndex[2] = {
+    { 0, -1 },
+    { -1, -1 },
+};
+
+
+static const HashTableValue JSDocumentTableValues[] =
+{
+    { "location", DontDelete | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentLocation), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentLocation) } },
+};
+
+static const HashTable JSDocumentTable = { 1, 1, true, JSDocumentTableValues, JSDocumentTableIndex };
+template<> EncodedJSValue JSC_HOST_CALL JSDocumentConstructor::construct(ExecState* state)
+{
+    auto* castedThis = jsCast<JSDocumentConstructor*>(state->callee());
+    ScriptExecutionContext* context = castedThis->scriptExecutionContext();
+    if (!context)
+        return throwConstructorDocumentUnavailableError(*state, "Document");
+    RefPtr<Document> object = Document::create(*context);
+    return JSValue::encode(asObject(toJS(state, castedThis->globalObject(), object.get())));
+}
+
+template<> JSValue JSDocumentConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
+{
+    return JSNode::getConstructor(vm, &globalObject);
+}
+
+template<> void JSDocumentConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
+{
+    putDirect(vm, vm.propertyNames->prototype, JSDocument::getPrototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
+    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("Document"))), ReadOnly | DontEnum);
+    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
+}
+
+template<> const ClassInfo JSDocumentConstructor::s_info = { "Document", &Base::s_info, 0, CREATE_METHOD_TABLE(JSDocumentConstructor) };
+
+/* Hash table for prototype */
+
+static const HashTableValue JSDocumentPrototypeTableValues[] =
+{
+    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentConstructor) } },
+    { "doctype", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentDoctype), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "implementation", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentImplementation), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "documentElement", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentDocumentElement), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "inputEncoding", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentInputEncoding), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "xmlEncoding", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentXMLEncoding), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "xmlVersion", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentXMLVersion), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentXMLVersion) } },
+    { "xmlStandalone", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentXMLStandalone), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentXMLStandalone) } },
+    { "documentURI", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentDocumentURI), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "defaultView", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentDefaultView), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "styleSheets", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentStyleSheets), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "contentType", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentContentType), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "title", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentTitle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentTitle) } },
+    { "referrer", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentReferrer), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "domain", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentDomain), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentDomain) } },
+    { "URL", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentURL), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "cookie", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentCookie), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentCookie) } },
+    { "body", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentBody), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentBody) } },
+    { "head", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentHead), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "images", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentImages), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "applets", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentApplets), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "links", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentLinks), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "forms", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentForms), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "anchors", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentAnchors), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "lastModified", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentLastModified), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "charset", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentCharset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "defaultCharset", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentDefaultCharset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "readyState", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentReadyState), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "characterSet", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentCharacterSet), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "preferredStylesheetSet", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentPreferredStylesheetSet), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "selectedStylesheetSet", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentSelectedStylesheetSet), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentSelectedStylesheetSet) } },
+    { "activeElement", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentActiveElement), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "compatMode", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentCompatMode), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "webkitIsFullScreen", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentWebkitIsFullScreen), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "webkitFullScreenKeyboardInputAllowed", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentWebkitFullScreenKeyboardInputAllowed), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "webkitCurrentFullScreenElement", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentWebkitCurrentFullScreenElement), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "webkitFullscreenEnabled", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentWebkitFullscreenEnabled), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "webkitFullscreenElement", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentWebkitFullscreenElement), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+#if ENABLE(POINTER_LOCK)
+    { "pointerLockElement", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentPointerLockElement), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(FONT_LOAD_EVENTS)
+    { "fonts", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentFonts), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "visibilityState", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentVisibilityState), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "hidden", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentHidden), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "currentScript", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentCurrentScript), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "origin", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOrigin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "scrollingElement", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentScrollingElement), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "onbeforecopy", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnbeforecopy), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnbeforecopy) } },
+    { "onbeforecut", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnbeforecut), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnbeforecut) } },
+    { "onbeforepaste", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnbeforepaste), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnbeforepaste) } },
+    { "oncopy", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOncopy), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOncopy) } },
+    { "oncut", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOncut), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOncut) } },
+    { "onpaste", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnpaste), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnpaste) } },
+    { "onselectstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnselectstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnselectstart) } },
+#if ENABLE(FULLSCREEN_API)
+    { "onwebkitfullscreenchange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitfullscreenchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitfullscreenchange) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(FULLSCREEN_API)
+    { "onwebkitfullscreenerror", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitfullscreenerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitfullscreenerror) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "onselectionchange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnselectionchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnselectionchange) } },
+    { "onreadystatechange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnreadystatechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnreadystatechange) } },
+#if ENABLE(CSP_NEXT)
+    { "onsecuritypolicyviolation", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnsecuritypolicyviolation), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnsecuritypolicyviolation) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(POINTER_LOCK)
+    { "onpointerlockchange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnpointerlockchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnpointerlockchange) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(POINTER_LOCK)
+    { "onpointerlockerror", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnpointerlockerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnpointerlockerror) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "onabort", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnabort), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnabort) } },
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+    { "onautocomplete", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnautocomplete), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnautocomplete) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+    { "onautocompleteerror", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnautocompleteerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnautocompleteerror) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "onblur", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnblur), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnblur) } },
+    { "oncanplay", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOncanplay), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOncanplay) } },
+    { "oncanplaythrough", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOncanplaythrough), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOncanplaythrough) } },
+    { "onchange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnchange) } },
+    { "onclick", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnclick), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnclick) } },
+    { "oncontextmenu", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOncontextmenu), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOncontextmenu) } },
+    { "ondblclick", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOndblclick), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOndblclick) } },
+    { "ondrag", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOndrag), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOndrag) } },
+    { "ondragend", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOndragend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOndragend) } },
+    { "ondragenter", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOndragenter), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOndragenter) } },
+    { "ondragleave", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOndragleave), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOndragleave) } },
+    { "ondragover", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOndragover), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOndragover) } },
+    { "ondragstart", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOndragstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOndragstart) } },
+    { "ondrop", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOndrop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOndrop) } },
+    { "ondurationchange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOndurationchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOndurationchange) } },
+    { "onemptied", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnemptied), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnemptied) } },
+    { "onended", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnended), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnended) } },
+    { "onerror", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnerror) } },
+    { "onfocus", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnfocus), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnfocus) } },
+    { "oninput", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOninput), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOninput) } },
+    { "oninvalid", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOninvalid), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOninvalid) } },
+    { "onkeydown", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnkeydown), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnkeydown) } },
+    { "onkeypress", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnkeypress), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnkeypress) } },
+    { "onkeyup", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnkeyup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnkeyup) } },
+    { "onload", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnload), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnload) } },
+    { "onloadeddata", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnloadeddata), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnloadeddata) } },
+    { "onloadedmetadata", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnloadedmetadata), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnloadedmetadata) } },
+    { "onloadstart", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnloadstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnloadstart) } },
+    { "onmousedown", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnmousedown), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnmousedown) } },
+    { "onmouseenter", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnmouseenter), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnmouseenter) } },
+    { "onmouseleave", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnmouseleave), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnmouseleave) } },
+    { "onmousemove", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnmousemove), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnmousemove) } },
+    { "onmouseout", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnmouseout), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnmouseout) } },
+    { "onmouseover", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnmouseover), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnmouseover) } },
+    { "onmouseup", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnmouseup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnmouseup) } },
+    { "onmousewheel", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnmousewheel), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnmousewheel) } },
+    { "onpause", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnpause), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnpause) } },
+    { "onplay", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnplay), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnplay) } },
+    { "onplaying", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnplaying), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnplaying) } },
+    { "onprogress", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnprogress), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnprogress) } },
+    { "onratechange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnratechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnratechange) } },
+    { "onreset", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnreset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnreset) } },
+    { "onresize", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnresize), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnresize) } },
+    { "onscroll", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnscroll), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnscroll) } },
+    { "onseeked", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnseeked), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnseeked) } },
+    { "onseeking", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnseeking), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnseeking) } },
+    { "onselect", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnselect), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnselect) } },
+    { "onstalled", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnstalled), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnstalled) } },
+    { "onsubmit", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnsubmit), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnsubmit) } },
+    { "onsuspend", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnsuspend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnsuspend) } },
+    { "ontimeupdate", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOntimeupdate), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOntimeupdate) } },
+    { "onvolumechange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnvolumechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnvolumechange) } },
+    { "onwaiting", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwaiting), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwaiting) } },
+    { "onsearch", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnsearch), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnsearch) } },
+    { "onwheel", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwheel), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwheel) } },
+#if ENABLE(TOUCH_EVENTS)
+    { "ontouchcancel", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOntouchcancel), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOntouchcancel) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(TOUCH_EVENTS)
+    { "ontouchend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOntouchend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOntouchend) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(TOUCH_EVENTS)
+    { "ontouchmove", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOntouchmove), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOntouchmove) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(TOUCH_EVENTS)
+    { "ontouchstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOntouchstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOntouchstart) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+    { "onwebkitmouseforcechanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitmouseforcechanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitmouseforcechanged) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+    { "onwebkitmouseforcedown", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitmouseforcedown), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitmouseforcedown) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+    { "onwebkitmouseforcewillbegin", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitmouseforcewillbegin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitmouseforcewillbegin) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+    { "onwebkitmouseforceup", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitmouseforceup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitmouseforceup) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+    { "onwebkitwillrevealbottom", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitwillrevealbottom), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitwillrevealbottom) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+    { "onwebkitwillrevealleft", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitwillrevealleft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitwillrevealleft) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+    { "onwebkitwillrevealright", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitwillrevealright), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitwillrevealright) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+    { "onwebkitwillrevealtop", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentOnwebkitwillrevealtop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSDocumentOnwebkitwillrevealtop) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "children", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentChildren), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "firstElementChild", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentFirstElementChild), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "lastElementChild", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentLastElementChild), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "childElementCount", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsDocumentChildElementCount), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "createElement", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateElement), (intptr_t) (1) } },
+    { "createDocumentFragment", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateDocumentFragment), (intptr_t) (0) } },
+    { "createTextNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateTextNode), (intptr_t) (0) } },
+    { "createComment", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateComment), (intptr_t) (0) } },
+    { "createCDATASection", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateCDATASection), (intptr_t) (0) } },
+    { "createProcessingInstruction", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateProcessingInstruction), (intptr_t) (0) } },
+    { "createAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateAttribute), (intptr_t) (0) } },
+    { "getElementsByTagName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionGetElementsByTagName), (intptr_t) (0) } },
+    { "importNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionImportNode), (intptr_t) (0) } },
+    { "createElementNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateElementNS), (intptr_t) (0) } },
+    { "createAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateAttributeNS), (intptr_t) (0) } },
+    { "getElementsByTagNameNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionGetElementsByTagNameNS), (intptr_t) (0) } },
+    { "adoptNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionAdoptNode), (intptr_t) (0) } },
+    { "createEvent", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateEvent), (intptr_t) (0) } },
+    { "createRange", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateRange), (intptr_t) (0) } },
+    { "createNodeIterator", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateNodeIterator), (intptr_t) (1) } },
+    { "createTreeWalker", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateTreeWalker), (intptr_t) (1) } },
+    { "getOverrideStyle", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionGetOverrideStyle), (intptr_t) (0) } },
+    { "createExpression", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateExpression), (intptr_t) (0) } },
+    { "createNSResolver", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateNSResolver), (intptr_t) (1) } },
+    { "evaluate", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionEvaluate), (intptr_t) (0) } },
+    { "execCommand", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionExecCommand), (intptr_t) (0) } },
+    { "queryCommandEnabled", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionQueryCommandEnabled), (intptr_t) (0) } },
+    { "queryCommandIndeterm", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionQueryCommandIndeterm), (intptr_t) (0) } },
+    { "queryCommandState", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionQueryCommandState), (intptr_t) (0) } },
+    { "queryCommandSupported", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionQueryCommandSupported), (intptr_t) (0) } },
+    { "queryCommandValue", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionQueryCommandValue), (intptr_t) (0) } },
+    { "getElementsByName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionGetElementsByName), (intptr_t) (0) } },
+    { "elementFromPoint", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionElementFromPoint), (intptr_t) (0) } },
+    { "caretRangeFromPoint", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCaretRangeFromPoint), (intptr_t) (0) } },
+    { "getSelection", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionGetSelection), (intptr_t) (0) } },
+    { "getCSSCanvasContext", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionGetCSSCanvasContext), (intptr_t) (4) } },
+    { "getElementsByClassName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionGetElementsByClassName), (intptr_t) (0) } },
+    { "hasFocus", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionHasFocus), (intptr_t) (0) } },
+    { "webkitCancelFullScreen", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionWebkitCancelFullScreen), (intptr_t) (0) } },
+    { "webkitExitFullscreen", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionWebkitExitFullscreen), (intptr_t) (0) } },
+#if ENABLE(POINTER_LOCK)
+    { "exitPointerLock", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionExitPointerLock), (intptr_t) (0) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(CSS_REGIONS)
+    { "webkitGetNamedFlows", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionWebkitGetNamedFlows), (intptr_t) (0) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "createTouch", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateTouch), (intptr_t) (0) } },
+    { "createTouchList", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionCreateTouchList), (intptr_t) (0) } },
+#if ENABLE(CUSTOM_ELEMENTS)
+    { "defineCustomElement", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionDefineCustomElement), (intptr_t) (2) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "getElementById", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionGetElementById), (intptr_t) (0) } },
+    { "prepend", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionPrepend), (intptr_t) (0) } },
+    { "append", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionAppend), (intptr_t) (0) } },
+    { "querySelector", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionQuerySelector), (intptr_t) (1) } },
+    { "querySelectorAll", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsDocumentPrototypeFunctionQuerySelectorAll), (intptr_t) (1) } },
+};
+
+const ClassInfo JSDocumentPrototype::s_info = { "DocumentPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSDocumentPrototype) };
+
+void JSDocumentPrototype::finishCreation(VM& vm)
+{
+    Base::finishCreation(vm);
+    reifyStaticProperties(vm, JSDocumentPrototypeTableValues, *this);
+}
+
+const ClassInfo JSDocument::s_info = { "Document", &Base::s_info, &JSDocumentTable, CREATE_METHOD_TABLE(JSDocument) };
+
+JSDocument::JSDocument(Structure* structure, JSDOMGlobalObject& globalObject, Ref<Document>&& impl)
+    : JSNode(structure, globalObject, WTFMove(impl))
+{
+}
+
+JSObject* JSDocument::createPrototype(VM& vm, JSGlobalObject* globalObject)
+{
+    return JSDocumentPrototype::create(vm, globalObject, JSDocumentPrototype::createStructure(vm, globalObject, JSNode::getPrototype(vm, globalObject)));
+}
+
+JSObject* JSDocument::getPrototype(VM& vm, JSGlobalObject* globalObject)
+{
+    return getDOMPrototype<JSDocument>(vm, globalObject);
+}
+
+bool JSDocument::getOwnPropertySlot(JSObject* object, ExecState* state, PropertyName propertyName, PropertySlot& slot)
+{
+    auto* thisObject = jsCast<JSDocument*>(object);
+    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
+    if (getStaticValueSlot<JSDocument, Base>(state, JSDocumentTable, thisObject, propertyName, slot))
+        return true;
+    return false;
+}
+
+EncodedJSValue jsDocumentDoctype(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "doctype");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.doctype()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentImplementation(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "implementation");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.implementation()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentDocumentElement(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "documentElement");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.documentElement()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentInputEncoding(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "inputEncoding");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.characterSetWithUTF8Fallback());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentXMLEncoding(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "xmlEncoding");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringOrNull(state, impl.xmlEncoding());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentXMLVersion(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "xmlVersion");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringOrNull(state, impl.xmlVersion());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentXMLStandalone(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "xmlStandalone");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.xmlStandalone());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentDocumentURI(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "documentURI");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.urlForBindings());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentDefaultView(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "defaultView");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.defaultView()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentStyleSheets(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "styleSheets");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.styleSheets()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentContentType(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "contentType");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.contentType());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentTitle(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "title");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.title());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentReferrer(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "referrer");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.referrer());
+    //DOM_XSS
+    if(cTaintLog::isDOM_XSS()) {
+      JSString* strPtr = result.toString(state);
+      strPtr->__dxx_taint(state)=100;
+      strPtr->__dxx_source(state)=eSourceTypeReferer;
+      //std::cout<< "inside Document.referer.getter() We have set the taint to " << result.toString(exec)->taint(exec) << std::endl;
+    }
+
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentDomain(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "domain");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.domain());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentURL(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "URL");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.urlForBindings());
+    //DOM_XSS
+    if(cTaintLog::isDOM_XSS_Exploit())
+    { 
+      //std::cout<< "inside Document.URL.getter()  " << result.toString(exec)->value(exec).utf8().data() << std::endl;
+      String str=decodeURLEscapeSequences(result.toString(state)->value(state));
+      JSValue ret  = jsStringWithCache(state, str);
+      //std::cout<< "decoded Document.URL.getter()  " << str.utf8().data() << std::endl;
+      return JSValue::encode(ret);
+    }
+
+    if(cTaintLog::isDOM_XSS()) {
+      JSString* strPtr = result.toString(state);
+      strPtr->__dxx_taint(state)=100;
+      strPtr->__dxx_source(state)=eSourceTypeDocumentUrl;
+      //strPtr->id() = rand();
+      //std::cout<< "inside Document.URL.getter() We have set the taint to " << result.toString(exec)->taint(exec) << std::endl;
+    }
+
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentCookie(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "cookie");
+    }
+    ExceptionCode ec = 0;
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.cookie(ec));
+    setDOMException(state, ec);
+
+    //DOM_XSS
+    if(cTaintLog::isDOM_XSS()) {
+      JSString* strPtr = result.toString(state);
+      strPtr->__dxx_taint(state)=100;
+      strPtr->__dxx_source(state)=eSourceTypeCookie;
+      //std::cout<< "inside Document.cookie.getter() We have set the taint to " << result.toString(exec)->taint(exec) << std::endl;
+
+    }
+
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentBody(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "body");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.bodyOrFrameset()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentHead(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "head");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.head()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentImages(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "images");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.images()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentApplets(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "applets");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.applets()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentLinks(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "links");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.links()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentForms(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "forms");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.forms()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentAnchors(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "anchors");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.anchors()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentLastModified(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "lastModified");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.lastModified());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentLocation(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "location");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.location()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentCharset(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "charset");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.characterSetWithUTF8Fallback());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentDefaultCharset(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "defaultCharset");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringOrUndefined(state, impl.defaultCharset());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentReadyState(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "readyState");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringOrUndefined(state, impl.readyState());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentCharacterSet(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "characterSet");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.characterSetWithUTF8Fallback());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentPreferredStylesheetSet(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "preferredStylesheetSet");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringOrNull(state, impl.preferredStylesheetSet());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentSelectedStylesheetSet(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "selectedStylesheetSet");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringOrNull(state, impl.selectedStylesheetSet());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentActiveElement(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "activeElement");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.activeElement()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentCompatMode(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "compatMode");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.compatMode());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentWebkitIsFullScreen(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "webkitIsFullScreen");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.webkitIsFullScreen());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentWebkitFullScreenKeyboardInputAllowed(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "webkitFullScreenKeyboardInputAllowed");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.webkitFullScreenKeyboardInputAllowed());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentWebkitCurrentFullScreenElement(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "webkitCurrentFullScreenElement");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.webkitCurrentFullScreenElement()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentWebkitFullscreenEnabled(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "webkitFullscreenEnabled");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.webkitFullscreenEnabled());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentWebkitFullscreenElement(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "webkitFullscreenElement");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.webkitFullscreenElement()));
+    return JSValue::encode(result);
+}
+
+
+#if ENABLE(POINTER_LOCK)
+EncodedJSValue jsDocumentPointerLockElement(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "pointerLockElement");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.pointerLockElement()));
+    return JSValue::encode(result);
+}
+
+#endif
+
+#if ENABLE(FONT_LOAD_EVENTS)
+EncodedJSValue jsDocumentFonts(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "fonts");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.fonts()));
+    return JSValue::encode(result);
+}
+
+#endif
+
+EncodedJSValue jsDocumentVisibilityState(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "visibilityState");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.visibilityState());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentHidden(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "hidden");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.hidden());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentCurrentScript(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "currentScript");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.currentScript()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentOrigin(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "origin");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.origin());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentScrollingElement(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "scrollingElement");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.scrollingElement()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentOnbeforecopy(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onbeforecopy");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforecopyEvent));
+}
+
+
+EncodedJSValue jsDocumentOnbeforecut(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onbeforecut");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforecutEvent));
+}
+
+
+EncodedJSValue jsDocumentOnbeforepaste(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onbeforepaste");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforepasteEvent));
+}
+
+
+EncodedJSValue jsDocumentOncopy(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "oncopy");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().copyEvent));
+}
+
+
+EncodedJSValue jsDocumentOncut(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "oncut");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().cutEvent));
+}
+
+
+EncodedJSValue jsDocumentOnpaste(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onpaste");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().pasteEvent));
+}
+
+
+EncodedJSValue jsDocumentOnselectstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onselectstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().selectstartEvent));
+}
+
+
+#if ENABLE(FULLSCREEN_API)
+EncodedJSValue jsDocumentOnwebkitfullscreenchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitfullscreenchange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitfullscreenchangeEvent));
+}
+
+#endif
+
+#if ENABLE(FULLSCREEN_API)
+EncodedJSValue jsDocumentOnwebkitfullscreenerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitfullscreenerror");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitfullscreenerrorEvent));
+}
+
+#endif
+
+EncodedJSValue jsDocumentOnselectionchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onselectionchange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().selectionchangeEvent));
+}
+
+
+EncodedJSValue jsDocumentOnreadystatechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return JSValue::encode(jsUndefined());
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().readystatechangeEvent));
+}
+
+
+#if ENABLE(CSP_NEXT)
+EncodedJSValue jsDocumentOnsecuritypolicyviolation(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onsecuritypolicyviolation");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().securitypolicyviolationEvent));
+}
+
+#endif
+
+#if ENABLE(POINTER_LOCK)
+EncodedJSValue jsDocumentOnpointerlockchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onpointerlockchange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().pointerlockchangeEvent));
+}
+
+#endif
+
+#if ENABLE(POINTER_LOCK)
+EncodedJSValue jsDocumentOnpointerlockerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onpointerlockerror");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().pointerlockerrorEvent));
+}
+
+#endif
+
+EncodedJSValue jsDocumentOnabort(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onabort");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().abortEvent));
+}
+
+
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+EncodedJSValue jsDocumentOnautocomplete(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onautocomplete");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().autocompleteEvent));
+}
+
+#endif
+
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+EncodedJSValue jsDocumentOnautocompleteerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onautocompleteerror");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().autocompleteerrorEvent));
+}
+
+#endif
+
+EncodedJSValue jsDocumentOnblur(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onblur");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().blurEvent));
+}
+
+
+EncodedJSValue jsDocumentOncanplay(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "oncanplay");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().canplayEvent));
+}
+
+
+EncodedJSValue jsDocumentOncanplaythrough(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "oncanplaythrough");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().canplaythroughEvent));
+}
+
+
+EncodedJSValue jsDocumentOnchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onchange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().changeEvent));
+}
+
+
+EncodedJSValue jsDocumentOnclick(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onclick");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().clickEvent));
+}
+
+
+EncodedJSValue jsDocumentOncontextmenu(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "oncontextmenu");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().contextmenuEvent));
+}
+
+
+EncodedJSValue jsDocumentOndblclick(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ondblclick");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dblclickEvent));
+}
+
+
+EncodedJSValue jsDocumentOndrag(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ondrag");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragEvent));
+}
+
+
+EncodedJSValue jsDocumentOndragend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ondragend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragendEvent));
+}
+
+
+EncodedJSValue jsDocumentOndragenter(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ondragenter");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragenterEvent));
+}
+
+
+EncodedJSValue jsDocumentOndragleave(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ondragleave");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragleaveEvent));
+}
+
+
+EncodedJSValue jsDocumentOndragover(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ondragover");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragoverEvent));
+}
+
+
+EncodedJSValue jsDocumentOndragstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ondragstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragstartEvent));
+}
+
+
+EncodedJSValue jsDocumentOndrop(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ondrop");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dropEvent));
+}
+
+
+EncodedJSValue jsDocumentOndurationchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ondurationchange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().durationchangeEvent));
+}
+
+
+EncodedJSValue jsDocumentOnemptied(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onemptied");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().emptiedEvent));
+}
+
+
+EncodedJSValue jsDocumentOnended(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onended");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().endedEvent));
+}
+
+
+EncodedJSValue jsDocumentOnerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onerror");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().errorEvent));
+}
+
+
+EncodedJSValue jsDocumentOnfocus(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onfocus");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().focusEvent));
+}
+
+
+EncodedJSValue jsDocumentOninput(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "oninput");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().inputEvent));
+}
+
+
+EncodedJSValue jsDocumentOninvalid(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "oninvalid");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().invalidEvent));
+}
+
+
+EncodedJSValue jsDocumentOnkeydown(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onkeydown");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().keydownEvent));
+}
+
+
+EncodedJSValue jsDocumentOnkeypress(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onkeypress");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().keypressEvent));
+}
+
+
+EncodedJSValue jsDocumentOnkeyup(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onkeyup");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().keyupEvent));
+}
+
+
+EncodedJSValue jsDocumentOnload(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onload");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadEvent));
+}
+
+
+EncodedJSValue jsDocumentOnloadeddata(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onloadeddata");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadeddataEvent));
+}
+
+
+EncodedJSValue jsDocumentOnloadedmetadata(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onloadedmetadata");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadedmetadataEvent));
+}
+
+
+EncodedJSValue jsDocumentOnloadstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onloadstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadstartEvent));
+}
+
+
+EncodedJSValue jsDocumentOnmousedown(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onmousedown");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mousedownEvent));
+}
+
+
+EncodedJSValue jsDocumentOnmouseenter(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return JSValue::encode(jsUndefined());
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseenterEvent));
+}
+
+
+EncodedJSValue jsDocumentOnmouseleave(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return JSValue::encode(jsUndefined());
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseleaveEvent));
+}
+
+
+EncodedJSValue jsDocumentOnmousemove(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onmousemove");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mousemoveEvent));
+}
+
+
+EncodedJSValue jsDocumentOnmouseout(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onmouseout");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseoutEvent));
+}
+
+
+EncodedJSValue jsDocumentOnmouseover(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onmouseover");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseoverEvent));
+}
+
+
+EncodedJSValue jsDocumentOnmouseup(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onmouseup");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseupEvent));
+}
+
+
+EncodedJSValue jsDocumentOnmousewheel(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onmousewheel");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mousewheelEvent));
+}
+
+
+EncodedJSValue jsDocumentOnpause(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onpause");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().pauseEvent));
+}
+
+
+EncodedJSValue jsDocumentOnplay(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onplay");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().playEvent));
+}
+
+
+EncodedJSValue jsDocumentOnplaying(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onplaying");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().playingEvent));
+}
+
+
+EncodedJSValue jsDocumentOnprogress(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onprogress");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().progressEvent));
+}
+
+
+EncodedJSValue jsDocumentOnratechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onratechange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().ratechangeEvent));
+}
+
+
+EncodedJSValue jsDocumentOnreset(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onreset");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().resetEvent));
+}
+
+
+EncodedJSValue jsDocumentOnresize(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onresize");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().resizeEvent));
+}
+
+
+EncodedJSValue jsDocumentOnscroll(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onscroll");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().scrollEvent));
+}
+
+
+EncodedJSValue jsDocumentOnseeked(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onseeked");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().seekedEvent));
+}
+
+
+EncodedJSValue jsDocumentOnseeking(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onseeking");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().seekingEvent));
+}
+
+
+EncodedJSValue jsDocumentOnselect(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onselect");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().selectEvent));
+}
+
+
+EncodedJSValue jsDocumentOnstalled(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onstalled");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().stalledEvent));
+}
+
+
+EncodedJSValue jsDocumentOnsubmit(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onsubmit");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().submitEvent));
+}
+
+
+EncodedJSValue jsDocumentOnsuspend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onsuspend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().suspendEvent));
+}
+
+
+EncodedJSValue jsDocumentOntimeupdate(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ontimeupdate");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().timeupdateEvent));
+}
+
+
+EncodedJSValue jsDocumentOnvolumechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onvolumechange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().volumechangeEvent));
+}
+
+
+EncodedJSValue jsDocumentOnwaiting(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwaiting");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().waitingEvent));
+}
+
+
+EncodedJSValue jsDocumentOnsearch(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onsearch");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().searchEvent));
+}
+
+
+EncodedJSValue jsDocumentOnwheel(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwheel");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().wheelEvent));
+}
+
+
+#if ENABLE(TOUCH_EVENTS)
+EncodedJSValue jsDocumentOntouchcancel(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ontouchcancel");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchcancelEvent));
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+EncodedJSValue jsDocumentOntouchend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ontouchend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchendEvent));
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+EncodedJSValue jsDocumentOntouchmove(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ontouchmove");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchmoveEvent));
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+EncodedJSValue jsDocumentOntouchstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "ontouchstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchstartEvent));
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+EncodedJSValue jsDocumentOnwebkitmouseforcechanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitmouseforcechanged");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforcechangedEvent));
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+EncodedJSValue jsDocumentOnwebkitmouseforcedown(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitmouseforcedown");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforcedownEvent));
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+EncodedJSValue jsDocumentOnwebkitmouseforcewillbegin(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitmouseforcewillbegin");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforcewillbeginEvent));
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+EncodedJSValue jsDocumentOnwebkitmouseforceup(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitmouseforceup");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforceupEvent));
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+EncodedJSValue jsDocumentOnwebkitwillrevealbottom(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitwillrevealbottom");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealbottomEvent));
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+EncodedJSValue jsDocumentOnwebkitwillrevealleft(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitwillrevealleft");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealleftEvent));
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+EncodedJSValue jsDocumentOnwebkitwillrevealright(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitwillrevealright");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealrightEvent));
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+EncodedJSValue jsDocumentOnwebkitwillrevealtop(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "onwebkitwillrevealtop");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealtopEvent));
+}
+
+#endif
+
+EncodedJSValue jsDocumentChildren(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "children");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.children()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentFirstElementChild(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "firstElementChild");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.firstElementChild()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentLastElementChild(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "lastElementChild");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.lastElementChild()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentChildElementCount(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDocumentCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Document", "childElementCount");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.childElementCount());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsDocumentConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    JSDocumentPrototype* domObject = jsDynamicCast<JSDocumentPrototype*>(JSValue::decode(thisValue));
+    if (!domObject)
+        return throwVMTypeError(state);
+    return JSValue::encode(JSDocument::getConstructor(state->vm(), domObject->globalObject()));
+}
+
+void setJSDocumentConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    JSDocumentPrototype* domObject = jsDynamicCast<JSDocumentPrototype*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!domObject)) {
+        throwVMTypeError(state);
+        return;
+    }
+    // Shadowing a built-in constructor
+    domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
+}
+
+//DOM_XSS
+
+void setJSDocumentURL(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+  JSValue value = JSValue::decode(encodedValue);
+  UNUSED_PARAM(thisValue);
+  JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+  if (UNLIKELY(!castedThis)) {
+    throwSetterTypeError(*state, "Document", "URL");
+    return;
+  }
+  auto& impl = castedThis->wrapped();
+  String nativeValue = value.toString(state)->value(state);
+  if (UNLIKELY(state->hadException()))
+    return;
+
+  if(cTaintLog::isDOM_XSS()) {
+    UNUSED_PARAM(state);
+     JSString* strPtr = value.toString(state);
+    cTaintLog::add_taint_log(strPtr->__dxx_source(state), "document.URL", strPtr->__dxx_taint(state), 0, strPtr->__dxx_id(), true);
+  }
+  //impl.setUrlForBindings(nativeValue);
+}
+
+void setJSDocumentXMLVersion(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "xmlVersion");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setXMLVersion(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSDocumentXMLStandalone(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "xmlStandalone");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    bool nativeValue = value.toBoolean(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setXMLStandalone(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSDocumentTitle(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "title");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setTitle(nativeValue);
+}
+
+
+void setJSDocumentDomain(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "domain");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setDomain(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSDocumentCookie(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "cookie");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setCookie(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSDocumentBody(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "body");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    if (UNLIKELY(!value.isUndefinedOrNull() && !value.inherits(JSHTMLElement::info()))) {
+        throwAttributeTypeError(*state, "Document", "body", "HTMLElement");
+        return;
+    };
+    HTMLElement* nativeValue = JSHTMLElement::toWrapped(value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setBodyOrFrameset(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSDocumentLocation(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "location");
+        return;
+    }
+    RefPtr<Location> forwardedImpl = castedThis->wrapped().location();
+    if (!forwardedImpl)
+        return;
+    auto& impl = *forwardedImpl;
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setHref(activeDOMWindow(state), firstDOMWindow(state), nativeValue);
+}
+
+
+void setJSDocumentSelectedStylesheetSet(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "selectedStylesheetSet");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setSelectedStylesheetSet(nativeValue);
+}
+
+
+void setJSDocumentOnbeforecopy(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onbeforecopy");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforecopyEvent, value);
+}
+
+
+void setJSDocumentOnbeforecut(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onbeforecut");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforecutEvent, value);
+}
+
+
+void setJSDocumentOnbeforepaste(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onbeforepaste");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforepasteEvent, value);
+}
+
+
+void setJSDocumentOncopy(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "oncopy");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().copyEvent, value);
+}
+
+
+void setJSDocumentOncut(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "oncut");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().cutEvent, value);
+}
+
+
+void setJSDocumentOnpaste(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onpaste");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().pasteEvent, value);
+}
+
+
+void setJSDocumentOnselectstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onselectstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().selectstartEvent, value);
+}
+
+
+#if ENABLE(FULLSCREEN_API)
+void setJSDocumentOnwebkitfullscreenchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitfullscreenchange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitfullscreenchangeEvent, value);
+}
+
+#endif
+
+#if ENABLE(FULLSCREEN_API)
+void setJSDocumentOnwebkitfullscreenerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitfullscreenerror");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitfullscreenerrorEvent, value);
+}
+
+#endif
+
+void setJSDocumentOnselectionchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onselectionchange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().selectionchangeEvent, value);
+}
+
+
+void setJSDocumentOnreadystatechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().readystatechangeEvent, value);
+}
+
+
+#if ENABLE(CSP_NEXT)
+void setJSDocumentOnsecuritypolicyviolation(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onsecuritypolicyviolation");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().securitypolicyviolationEvent, value);
+}
+
+#endif
+
+#if ENABLE(POINTER_LOCK)
+void setJSDocumentOnpointerlockchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onpointerlockchange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().pointerlockchangeEvent, value);
+}
+
+#endif
+
+#if ENABLE(POINTER_LOCK)
+void setJSDocumentOnpointerlockerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onpointerlockerror");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().pointerlockerrorEvent, value);
+}
+
+#endif
+
+void setJSDocumentOnabort(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onabort");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().abortEvent, value);
+}
+
+
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+void setJSDocumentOnautocomplete(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onautocomplete");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().autocompleteEvent, value);
+}
+
+#endif
+
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+void setJSDocumentOnautocompleteerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onautocompleteerror");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().autocompleteerrorEvent, value);
+}
+
+#endif
+
+void setJSDocumentOnblur(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onblur");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().blurEvent, value);
+}
+
+
+void setJSDocumentOncanplay(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "oncanplay");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().canplayEvent, value);
+}
+
+
+void setJSDocumentOncanplaythrough(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "oncanplaythrough");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().canplaythroughEvent, value);
+}
+
+
+void setJSDocumentOnchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onchange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().changeEvent, value);
+}
+
+
+void setJSDocumentOnclick(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onclick");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().clickEvent, value);
+}
+
+
+void setJSDocumentOncontextmenu(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "oncontextmenu");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().contextmenuEvent, value);
+}
+
+
+void setJSDocumentOndblclick(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ondblclick");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dblclickEvent, value);
+}
+
+
+void setJSDocumentOndrag(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ondrag");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragEvent, value);
+}
+
+
+void setJSDocumentOndragend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ondragend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragendEvent, value);
+}
+
+
+void setJSDocumentOndragenter(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ondragenter");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragenterEvent, value);
+}
+
+
+void setJSDocumentOndragleave(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ondragleave");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragleaveEvent, value);
+}
+
+
+void setJSDocumentOndragover(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ondragover");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragoverEvent, value);
+}
+
+
+void setJSDocumentOndragstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ondragstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragstartEvent, value);
+}
+
+
+void setJSDocumentOndrop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ondrop");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dropEvent, value);
+}
+
+
+void setJSDocumentOndurationchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ondurationchange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().durationchangeEvent, value);
+}
+
+
+void setJSDocumentOnemptied(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onemptied");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().emptiedEvent, value);
+}
+
+
+void setJSDocumentOnended(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onended");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().endedEvent, value);
+}
+
+
+void setJSDocumentOnerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onerror");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().errorEvent, value);
+}
+
+
+void setJSDocumentOnfocus(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onfocus");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().focusEvent, value);
+}
+
+
+void setJSDocumentOninput(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "oninput");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().inputEvent, value);
+}
+
+
+void setJSDocumentOninvalid(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "oninvalid");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().invalidEvent, value);
+}
+
+
+void setJSDocumentOnkeydown(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onkeydown");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().keydownEvent, value);
+}
+
+
+void setJSDocumentOnkeypress(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onkeypress");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().keypressEvent, value);
+}
+
+
+void setJSDocumentOnkeyup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onkeyup");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().keyupEvent, value);
+}
+
+
+void setJSDocumentOnload(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onload");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadEvent, value);
+}
+
+
+void setJSDocumentOnloadeddata(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onloadeddata");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadeddataEvent, value);
+}
+
+
+void setJSDocumentOnloadedmetadata(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onloadedmetadata");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadedmetadataEvent, value);
+}
+
+
+void setJSDocumentOnloadstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onloadstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadstartEvent, value);
+}
+
+
+void setJSDocumentOnmousedown(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onmousedown");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mousedownEvent, value);
+}
+
+
+void setJSDocumentOnmouseenter(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseenterEvent, value);
+}
+
+
+void setJSDocumentOnmouseleave(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseleaveEvent, value);
+}
+
+
+void setJSDocumentOnmousemove(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onmousemove");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mousemoveEvent, value);
+}
+
+
+void setJSDocumentOnmouseout(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onmouseout");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseoutEvent, value);
+}
+
+
+void setJSDocumentOnmouseover(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onmouseover");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseoverEvent, value);
+}
+
+
+void setJSDocumentOnmouseup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onmouseup");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseupEvent, value);
+}
+
+
+void setJSDocumentOnmousewheel(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onmousewheel");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mousewheelEvent, value);
+}
+
+
+void setJSDocumentOnpause(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onpause");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().pauseEvent, value);
+}
+
+
+void setJSDocumentOnplay(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onplay");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().playEvent, value);
+}
+
+
+void setJSDocumentOnplaying(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onplaying");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().playingEvent, value);
+}
+
+
+void setJSDocumentOnprogress(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onprogress");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().progressEvent, value);
+}
+
+
+void setJSDocumentOnratechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onratechange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().ratechangeEvent, value);
+}
+
+
+void setJSDocumentOnreset(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onreset");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().resetEvent, value);
+}
+
+
+void setJSDocumentOnresize(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onresize");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().resizeEvent, value);
+}
+
+
+void setJSDocumentOnscroll(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onscroll");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().scrollEvent, value);
+}
+
+
+void setJSDocumentOnseeked(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onseeked");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().seekedEvent, value);
+}
+
+
+void setJSDocumentOnseeking(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onseeking");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().seekingEvent, value);
+}
+
+
+void setJSDocumentOnselect(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onselect");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().selectEvent, value);
+}
+
+
+void setJSDocumentOnstalled(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onstalled");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().stalledEvent, value);
+}
+
+
+void setJSDocumentOnsubmit(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onsubmit");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().submitEvent, value);
+}
+
+
+void setJSDocumentOnsuspend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onsuspend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().suspendEvent, value);
+}
+
+
+void setJSDocumentOntimeupdate(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ontimeupdate");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().timeupdateEvent, value);
+}
+
+
+void setJSDocumentOnvolumechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onvolumechange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().volumechangeEvent, value);
+}
+
+
+void setJSDocumentOnwaiting(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwaiting");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().waitingEvent, value);
+}
+
+
+void setJSDocumentOnsearch(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onsearch");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().searchEvent, value);
+}
+
+
+void setJSDocumentOnwheel(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwheel");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().wheelEvent, value);
+}
+
+
+#if ENABLE(TOUCH_EVENTS)
+void setJSDocumentOntouchcancel(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ontouchcancel");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchcancelEvent, value);
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+void setJSDocumentOntouchend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ontouchend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchendEvent, value);
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+void setJSDocumentOntouchmove(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ontouchmove");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchmoveEvent, value);
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+void setJSDocumentOntouchstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "ontouchstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchstartEvent, value);
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+void setJSDocumentOnwebkitmouseforcechanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitmouseforcechanged");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforcechangedEvent, value);
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+void setJSDocumentOnwebkitmouseforcedown(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitmouseforcedown");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforcedownEvent, value);
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+void setJSDocumentOnwebkitmouseforcewillbegin(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitmouseforcewillbegin");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforcewillbeginEvent, value);
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+void setJSDocumentOnwebkitmouseforceup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitmouseforceup");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforceupEvent, value);
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+void setJSDocumentOnwebkitwillrevealbottom(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitwillrevealbottom");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealbottomEvent, value);
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+void setJSDocumentOnwebkitwillrevealleft(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitwillrevealleft");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealleftEvent, value);
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+void setJSDocumentOnwebkitwillrevealright(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitwillrevealright");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealrightEvent, value);
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+void setJSDocumentOnwebkitwillrevealtop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSDocument* castedThis = jsDocumentCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Document", "onwebkitwillrevealtop");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealtopEvent, value);
+}
+
+#endif
+
+JSValue JSDocument::getConstructor(VM& vm, const JSGlobalObject* globalObject)
+{
+    return getDOMConstructor<JSDocumentConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateElement(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createElement");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    String tagName = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createElementForBindings(tagName, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateDocumentFragment(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createDocumentFragment");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createDocumentFragment()));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateTextNode(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createTextNode");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String data = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createTextNode(data)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateComment(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createComment");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String data = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createComment(data)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateCDATASection(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createCDATASection");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String data = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createCDATASection(data, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateProcessingInstruction(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createProcessingInstruction");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String target = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String data = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createProcessingInstruction(target, data, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateAttribute(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createAttribute");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String name = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createAttribute(name, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementsByTagName(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "getElementsByTagName");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String tagname = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getElementsByTagName(tagname)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionImportNode(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "importNode");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    Node* importedNode = JSNode::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+
+    size_t argsCount = state->argumentCount();
+    if (argsCount <= 1) {
+        JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.importNode(importedNode, ec)));
+
+        setDOMException(state, ec);
+        return JSValue::encode(result);
+    }
+
+    bool deep = state->argument(1).toBoolean(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.importNode(importedNode, deep, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateElementNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createElementNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String qualifiedName = valueToStringWithNullCheck(state, state->argument(1));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createElementNS(namespaceURI, qualifiedName, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateAttributeNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createAttributeNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String qualifiedName = valueToStringWithNullCheck(state, state->argument(1));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createAttributeNS(namespaceURI, qualifiedName, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementsByTagNameNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "getElementsByTagNameNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String namespaceURI = valueToStringWithNullCheck(state, state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String localName = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getElementsByTagNameNS(namespaceURI, localName)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionAdoptNode(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "adoptNode");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    Node* source = JSNode::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.adoptNode(source, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateEvent(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createEvent");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String eventType = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createEvent(eventType, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateRange(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createRange");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createRange()));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateNodeIterator(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createNodeIterator");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    Node* root = JSNode::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+
+    size_t argsCount = state->argumentCount();
+    if (argsCount <= 1) {
+        JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createNodeIterator(root, ec)));
+
+        setDOMException(state, ec);
+        return JSValue::encode(result);
+    }
+
+    unsigned whatToShow = state->argument(1).isUndefined() ? 0xFFFFFFFF : toUInt32(state, state->uncheckedArgument(1), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    RefPtr<NodeFilter> filter;
+    if (!state->argument(2).isUndefinedOrNull()) {
+        if (!state->uncheckedArgument(2).isObject())
+            return throwArgumentMustBeFunctionError(*state, 2, "filter", "Document", "createNodeIterator");
+        filter = JSNodeFilter::create(asObject(state->uncheckedArgument(2)), castedThis->globalObject());
+    }
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createNodeIterator(root, whatToShow, filter.get(), ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateTreeWalker(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createTreeWalker");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    Node* root = JSNode::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+
+    size_t argsCount = state->argumentCount();
+    if (argsCount <= 1) {
+        JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createTreeWalker(root, ec)));
+
+        setDOMException(state, ec);
+        return JSValue::encode(result);
+    }
+
+    unsigned whatToShow = state->argument(1).isUndefined() ? 0xFFFFFFFF : toUInt32(state, state->uncheckedArgument(1), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    RefPtr<NodeFilter> filter;
+    if (!state->argument(2).isUndefinedOrNull()) {
+        if (!state->uncheckedArgument(2).isObject())
+            return throwArgumentMustBeFunctionError(*state, 2, "filter", "Document", "createTreeWalker");
+        filter = JSNodeFilter::create(asObject(state->uncheckedArgument(2)), castedThis->globalObject());
+    }
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createTreeWalker(root, whatToShow, filter.get(), ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetOverrideStyle(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "getOverrideStyle");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    Element* element = JSElement::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String pseudoElement = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getOverrideStyle(element, pseudoElement)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateExpression(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createExpression");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String expression = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    RefPtr<XPathNSResolver> customResolver;
+    XPathNSResolver* resolver = JSXPathNSResolver::toWrapped(state->argument(1));
+    if (!resolver) {
+        customResolver = JSCustomXPathNSResolver::create(state, state->argument(1));
+        if (UNLIKELY(state->hadException()))
+            return JSValue::encode(jsUndefined());
+        resolver = customResolver.get();
+    }
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.createExpression(expression, resolver, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateNSResolver(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createNSResolver");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    Node* nodeResolver = JSNode::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.createNSResolver(nodeResolver)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionEvaluate(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "evaluate");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String expression = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    Node* contextNode = JSNode::toWrapped(state->argument(1));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    RefPtr<XPathNSResolver> customResolver;
+    XPathNSResolver* resolver = JSXPathNSResolver::toWrapped(state->argument(2));
+    if (!resolver) {
+        customResolver = JSCustomXPathNSResolver::create(state, state->argument(2));
+        if (UNLIKELY(state->hadException()))
+            return JSValue::encode(jsUndefined());
+        resolver = customResolver.get();
+    }
+    uint16_t type = toUInt16(state, state->argument(3), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    XPathResult* inResult = JSXPathResult::toWrapped(state->argument(4));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.evaluate(expression, contextNode, resolver, type, inResult, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionExecCommand(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "execCommand");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String command = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    bool userInterface = state->argument(1).toBoolean(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String value = valueToStringWithUndefinedOrNullCheck(state, state->argument(2));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsBoolean(impl.execCommand(command, userInterface, value));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandEnabled(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "queryCommandEnabled");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String command = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsBoolean(impl.queryCommandEnabled(command));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandIndeterm(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "queryCommandIndeterm");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String command = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsBoolean(impl.queryCommandIndeterm(command));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandState(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "queryCommandState");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String command = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsBoolean(impl.queryCommandState(command));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandSupported(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "queryCommandSupported");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String command = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsBoolean(impl.queryCommandSupported(command));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQueryCommandValue(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "queryCommandValue");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String command = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsStringWithCache(state, impl.queryCommandValue(command));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementsByName(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "getElementsByName");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String elementName = state->argument(0).toString(state)->toAtomicString(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getElementsByName(elementName)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionElementFromPoint(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "elementFromPoint");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    int x = toInt32(state, state->argument(0), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int y = toInt32(state, state->argument(1), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.elementFromPoint(x, y)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCaretRangeFromPoint(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "caretRangeFromPoint");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    int x = toInt32(state, state->argument(0), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int y = toInt32(state, state->argument(1), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.caretRangeFromPoint(x, y)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetSelection(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "getSelection");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getSelection()));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetCSSCanvasContext(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "getCSSCanvasContext");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 4))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    String contextId = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String name = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int width = toInt32(state, state->argument(2), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int height = toInt32(state, state->argument(3), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getCSSCanvasContext(contextId, name, width, height)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementsByClassName(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "getElementsByClassName");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    String classNames = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getElementsByClassName(classNames)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionHasFocus(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "hasFocus");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.hasFocus());
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionWebkitCancelFullScreen(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "webkitCancelFullScreen");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    impl.webkitCancelFullScreen();
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionWebkitExitFullscreen(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "webkitExitFullscreen");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    impl.webkitExitFullscreen();
+    return JSValue::encode(jsUndefined());
+}
+
+#if ENABLE(POINTER_LOCK)
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionExitPointerLock(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "exitPointerLock");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    impl.exitPointerLock();
+    return JSValue::encode(jsUndefined());
+}
+
+#endif
+
+#if ENABLE(CSS_REGIONS)
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionWebkitGetNamedFlows(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "webkitGetNamedFlows");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.webkitGetNamedFlows()));
+    return JSValue::encode(result);
+}
+
+#endif
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateTouch(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createTouch");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    DOMWindow* window = JSDOMWindow::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    EventTarget* target = JSEventTarget::toWrapped(state->argument(1));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int identifier = toInt32(state, state->argument(2), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int pageX = toInt32(state, state->argument(3), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int pageY = toInt32(state, state->argument(4), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int screenX = toInt32(state, state->argument(5), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int screenY = toInt32(state, state->argument(6), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int webkitRadiusX = toInt32(state, state->argument(7), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    int webkitRadiusY = toInt32(state, state->argument(8), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    float webkitRotationAngle = state->argument(9).toFloat(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    float webkitForce = state->argument(10).toFloat(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.createTouch(window, target, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionCreateTouchList(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "createTouchList");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    return JSValue::encode(castedThis->createTouchList(*state));
+}
+
+#if ENABLE(CUSTOM_ELEMENTS)
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionDefineCustomElement(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "defineCustomElement");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    return JSValue::encode(castedThis->defineCustomElement(*state));
+}
+
+#endif
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionGetElementById(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "getElementById");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    AtomicString elementId = state->argument(0).toString(state)->toExistingAtomicString(state).get();
+    if (elementId.isNull())
+        return JSValue::encode(jsNull());
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getElementById(elementId)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionPrepend(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "prepend");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    return JSValue::encode(castedThis->prepend(*state));
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionAppend(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "append");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    return JSValue::encode(castedThis->append(*state));
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQuerySelector(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "querySelector");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    String selectors = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.querySelector(selectors, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsDocumentPrototypeFunctionQuerySelectorAll(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDocumentCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Document", "querySelectorAll");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSDocument::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    String selectors = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.querySelectorAll(selectors, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+void JSDocument::visitChildren(JSCell* cell, SlotVisitor& visitor)
+{
+    auto* thisObject = jsCast<JSDocument*>(cell);
+    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
+    Base::visitChildren(thisObject, visitor);
+    thisObject->wrapped().visitJSEventListeners(visitor);
+}
+
+Document* JSDocument::toWrapped(JSC::JSValue value)
+{
+    if (auto* wrapper = jsDocumentCast(value))
+        return &wrapper->wrapped();
+    return nullptr;
+}
+
+}
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/dom_generated/JSElement.cpp qtwebkit/Source/WebCore/dom_generated/JSElement.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/dom_generated/JSElement.cpp	1969-12-31 16:00:00.000000000 -0800
+++ qtwebkit/Source/WebCore/dom_generated/JSElement.cpp	2018-04-30 14:47:23.452799000 -0700
@@ -0,0 +1,4976 @@
+/*
+    This file is part of the WebKit open source project.
+    This file has been generated by generate-bindings.pl. DO NOT MODIFY!
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "config.h"
+#include "JSElement.h"
+
+#include "Attr.h"
+#include "CSSStyleDeclaration.h"
+#include "ClientRect.h"
+#include "ClientRectList.h"
+#include "DOMStringMap.h"
+#include "DOMTokenList.h"
+#include "Element.h"
+#include "ExceptionCode.h"
+#include "HTMLCollection.h"
+#include "HTMLNames.h"
+#include "JSAttr.h"
+#include "JSCSSStyleDeclaration.h"
+#include "JSClientRect.h"
+#include "JSClientRectList.h"
+#include "JSDOMBinding.h"
+#include "JSDOMConstructor.h"
+#include "JSDOMStringMap.h"
+#include "JSDOMTokenList.h"
+#include "JSElement.h"
+#include "JSEventListener.h"
+#include "JSHTMLCollection.h"
+#include "JSNamedNodeMap.h"
+#include "JSNodeList.h"
+#include "JSRange.h"
+#include "NameNodeList.h"
+#include "NamedNodeMap.h"
+#include "NodeList.h"
+#include "Range.h"
+#include "ShadowRoot.h"
+#include "StyleProperties.h"
+#include "URL.h"
+#include <runtime/Error.h>
+#include <runtime/JSArray.h>
+#include <runtime/JSString.h>
+#include <wtf/GetPtr.h>
+
+#if ENABLE(SHADOW_DOM)
+#include "Dictionary.h"
+#include "HTMLSlotElement.h"
+#include "JSHTMLSlotElement.h"
+#include "JSShadowRoot.h"
+#endif
+
+#include <iostream>
+#include <API/JSBase.h>
+
+using namespace JSC;
+
+namespace WebCore {
+
+// Functions
+
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttribute(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttribute(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttribute(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNode(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNode(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNode(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagName(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributes(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagNameNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNodeNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNodeNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttribute(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributeNS(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionFocus(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionBlur(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoView(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNames(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoViewIfNeeded(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByLines(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByPages(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByClassName(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionMatches(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionClosest(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitMatchesSelector(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetClientRects(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetBoundingClientRect(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullScreen(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullscreen(JSC::ExecState*);
+#if ENABLE(POINTER_LOCK)
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRequestPointerLock(JSC::ExecState*);
+#endif
+#if ENABLE(CSS_REGIONS)
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitGetRegionFlowRanges(JSC::ExecState*);
+#endif
+#if ENABLE(SHADOW_DOM)
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAttachShadow(JSC::ExecState*);
+#endif
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionBefore(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAfter(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionReplaceWith(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemove(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionPrepend(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAppend(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelector(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelectorAll(JSC::ExecState*);
+
+// Attributes
+
+JSC::EncodedJSValue jsElementTagName(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementAttributes(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementStyle(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementId(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementId(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOffsetLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementOffsetTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementOffsetWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementOffsetHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementClientLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementClientTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementClientWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementClientHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementScrollLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementScrollLeft(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementScrollTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementScrollTop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementScrollWidth(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementScrollHeight(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementOffsetParent(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementInnerHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementInnerHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOuterHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOuterHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementClassName(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementClassName(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementClassList(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementClassList(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementDataset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+#if ENABLE(CSS_REGIONS)
+JSC::EncodedJSValue jsElementWebkitRegionOverset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+#endif
+#if ENABLE(SHADOW_DOM)
+JSC::EncodedJSValue jsElementShadowRoot(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+#endif
+#if ENABLE(SHADOW_DOM)
+JSC::EncodedJSValue jsElementSlot(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementSlot(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsElementOnbeforecopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnbeforecopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnbeforecut(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnbeforecut(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnbeforepaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnbeforepaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOncopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOncopy(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOncut(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOncut(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnpaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnpaste(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnselectstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnselectstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#if ENABLE(FULLSCREEN_API)
+JSC::EncodedJSValue jsElementOnwebkitfullscreenchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitfullscreenchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(FULLSCREEN_API)
+JSC::EncodedJSValue jsElementOnwebkitfullscreenerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitfullscreenerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsElementOnanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOntransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOntransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnwebkitanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitanimationend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnwebkitanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitanimationiteration(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnwebkitanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitanimationstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnwebkittransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkittransitionend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#if ENABLE(IOS_GESTURE_EVENTS)
+JSC::EncodedJSValue jsElementOngesturechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOngesturechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(IOS_GESTURE_EVENTS)
+JSC::EncodedJSValue jsElementOngestureend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOngestureend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(IOS_GESTURE_EVENTS)
+JSC::EncodedJSValue jsElementOngesturestart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOngesturestart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsElementOnfocusin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnfocusin(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnfocusout(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnfocusout(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnbeforeload(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnbeforeload(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#if ENABLE(ENCRYPTED_MEDIA)
+JSC::EncodedJSValue jsElementOnwebkitkeyadded(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitkeyadded(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(ENCRYPTED_MEDIA)
+JSC::EncodedJSValue jsElementOnwebkitkeyerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitkeyerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(ENCRYPTED_MEDIA)
+JSC::EncodedJSValue jsElementOnwebkitkeymessage(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitkeymessage(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)
+JSC::EncodedJSValue jsElementOnwebkitneedkey(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitneedkey(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(VIDEO_PRESENTATION_MODE)
+JSC::EncodedJSValue jsElementOnwebkitpresentationmodechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitpresentationmodechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WIRELESS_PLAYBACK_TARGET)
+JSC::EncodedJSValue jsElementOnwebkitcurrentplaybacktargetiswirelesschanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitcurrentplaybacktargetiswirelesschanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WIRELESS_PLAYBACK_TARGET)
+JSC::EncodedJSValue jsElementOnwebkitplaybacktargetavailabilitychanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitplaybacktargetavailabilitychanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsElementOnabort(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnabort(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+JSC::EncodedJSValue jsElementOnautocomplete(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnautocomplete(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+JSC::EncodedJSValue jsElementOnautocompleteerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnautocompleteerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsElementOnblur(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnblur(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOncanplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOncanplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOncanplaythrough(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOncanplaythrough(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOncontextmenu(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOncontextmenu(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOndblclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOndblclick(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOndrag(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOndrag(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOndragend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOndragend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOndragenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOndragenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOndragleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOndragleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOndragover(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOndragover(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOndragstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOndragstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOndrop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOndrop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOndurationchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOndurationchange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnemptied(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnemptied(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnended(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnended(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnerror(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnfocus(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnfocus(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOninput(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOninput(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOninvalid(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOninvalid(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnkeydown(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnkeydown(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnkeypress(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnkeypress(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnkeyup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnkeyup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnload(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnload(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnloadeddata(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnloadeddata(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnloadedmetadata(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnloadedmetadata(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnloadstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnloadstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnmousedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnmousedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnmouseenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnmouseenter(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnmouseleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnmouseleave(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnmousemove(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnmousemove(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnmouseout(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnmouseout(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnmouseover(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnmouseover(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnmouseup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnmouseup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnmousewheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnmousewheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnpause(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnpause(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnplay(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnplaying(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnplaying(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnprogress(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnprogress(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnratechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnratechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnreset(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnreset(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnresize(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnresize(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnscroll(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnscroll(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnseeked(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnseeked(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnseeking(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnseeking(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnselect(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnselect(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnstalled(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnstalled(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnsubmit(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnsubmit(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnsuspend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnsuspend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOntimeupdate(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOntimeupdate(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnvolumechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnvolumechange(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnwaiting(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwaiting(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnsearch(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnsearch(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsElementOnwheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwheel(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#if ENABLE(TOUCH_EVENTS)
+JSC::EncodedJSValue jsElementOntouchcancel(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOntouchcancel(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(TOUCH_EVENTS)
+JSC::EncodedJSValue jsElementOntouchend(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOntouchend(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(TOUCH_EVENTS)
+JSC::EncodedJSValue jsElementOntouchmove(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOntouchmove(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(TOUCH_EVENTS)
+JSC::EncodedJSValue jsElementOntouchstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOntouchstart(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+JSC::EncodedJSValue jsElementOnwebkitmouseforcechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitmouseforcechanged(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+JSC::EncodedJSValue jsElementOnwebkitmouseforcedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitmouseforcedown(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+JSC::EncodedJSValue jsElementOnwebkitmouseforcewillbegin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitmouseforcewillbegin(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+JSC::EncodedJSValue jsElementOnwebkitmouseforceup(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitmouseforceup(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+JSC::EncodedJSValue jsElementOnwebkitwillrevealbottom(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitwillrevealbottom(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+JSC::EncodedJSValue jsElementOnwebkitwillrevealleft(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitwillrevealleft(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+JSC::EncodedJSValue jsElementOnwebkitwillrevealright(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitwillrevealright(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+JSC::EncodedJSValue jsElementOnwebkitwillrevealtop(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementOnwebkitwillrevealtop(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+#endif
+JSC::EncodedJSValue jsElementPreviousElementSibling(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementNextElementSibling(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+#if ENABLE(SHADOW_DOM)
+JSC::EncodedJSValue jsElementAssignedSlot(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+#endif
+JSC::EncodedJSValue jsElementChildren(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementFirstElementChild(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementLastElementChild(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementChildElementCount(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+
+class JSElementPrototype : public JSC::JSNonFinalObject {
+public:
+    typedef JSC::JSNonFinalObject Base;
+    static JSElementPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
+    {
+        JSElementPrototype* ptr = new (NotNull, JSC::allocateCell<JSElementPrototype>(vm.heap)) JSElementPrototype(vm, globalObject, structure);
+        ptr->finishCreation(vm);
+        return ptr;
+    }
+
+    DECLARE_INFO;
+    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
+    {
+        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
+    }
+
+private:
+    JSElementPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
+        : JSC::JSNonFinalObject(vm, structure)
+    {
+    }
+
+    void finishCreation(JSC::VM&);
+};
+
+typedef JSDOMConstructorNotConstructable<JSElement> JSElementConstructor;
+
+/* Hash table for constructor */
+
+static const HashTableValue JSElementConstructorTableValues[] =
+{
+    { "ALLOW_KEYBOARD_INPUT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
+};
+
+
+COMPILE_ASSERT(1 == Element::ALLOW_KEYBOARD_INPUT, ElementEnumALLOW_KEYBOARD_INPUTIsWrongUseDoNotCheckConstants);
+
+template<> JSValue JSElementConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
+{
+    return JSNode::getConstructor(vm, &globalObject);
+}
+
+template<> void JSElementConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
+{
+    putDirect(vm, vm.propertyNames->prototype, JSElement::getPrototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
+    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("Element"))), ReadOnly | DontEnum);
+    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
+    reifyStaticProperties(vm, JSElementConstructorTableValues, *this);
+}
+
+template<> const ClassInfo JSElementConstructor::s_info = { "Element", &Base::s_info, 0, CREATE_METHOD_TABLE(JSElementConstructor) };
+
+/* Hash table for prototype */
+
+static const HashTableValue JSElementPrototypeTableValues[] =
+{
+    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementConstructor) } },
+    { "tagName", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementTagName), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "attributes", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementAttributes), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "style", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementStyle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "id", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementId), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementId) } },
+    { "offsetLeft", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetLeft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "offsetTop", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetTop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "offsetWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "offsetHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "clientLeft", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientLeft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "clientTop", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientTop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "clientWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "clientHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClientHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "scrollLeft", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollLeft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementScrollLeft) } },
+    { "scrollTop", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollTop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementScrollTop) } },
+    { "scrollWidth", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollWidth), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "scrollHeight", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementScrollHeight), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "offsetParent", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOffsetParent), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "innerHTML", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementInnerHTML), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementInnerHTML) } },
+    { "outerHTML", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOuterHTML), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOuterHTML) } },
+    { "className", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClassName), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementClassName) } },
+    { "classList", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementClassList), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementClassList) } },
+    { "dataset", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementDataset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+#if ENABLE(CSS_REGIONS)
+    { "webkitRegionOverset", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementWebkitRegionOverset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(SHADOW_DOM)
+    { "shadowRoot", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementShadowRoot), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(SHADOW_DOM)
+    { "slot", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementSlot), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementSlot) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "onbeforecopy", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforecopy), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforecopy) } },
+    { "onbeforecut", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforecut), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforecut) } },
+    { "onbeforepaste", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforepaste), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforepaste) } },
+    { "oncopy", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOncopy), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOncopy) } },
+    { "oncut", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOncut), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOncut) } },
+    { "onpaste", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnpaste), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnpaste) } },
+    { "onselectstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnselectstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnselectstart) } },
+#if ENABLE(FULLSCREEN_API)
+    { "onwebkitfullscreenchange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitfullscreenchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitfullscreenchange) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(FULLSCREEN_API)
+    { "onwebkitfullscreenerror", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitfullscreenerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitfullscreenerror) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "onanimationend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnanimationend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnanimationend) } },
+    { "onanimationiteration", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnanimationiteration), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnanimationiteration) } },
+    { "onanimationstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnanimationstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnanimationstart) } },
+    { "ontransitionend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOntransitionend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOntransitionend) } },
+    { "onwebkitanimationend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitanimationend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitanimationend) } },
+    { "onwebkitanimationiteration", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitanimationiteration), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitanimationiteration) } },
+    { "onwebkitanimationstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitanimationstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitanimationstart) } },
+    { "onwebkittransitionend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkittransitionend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkittransitionend) } },
+#if ENABLE(IOS_GESTURE_EVENTS)
+    { "ongesturechange", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOngesturechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOngesturechange) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(IOS_GESTURE_EVENTS)
+    { "ongestureend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOngestureend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOngestureend) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(IOS_GESTURE_EVENTS)
+    { "ongesturestart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOngesturestart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOngesturestart) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "onfocusin", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnfocusin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnfocusin) } },
+    { "onfocusout", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnfocusout), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnfocusout) } },
+    { "onbeforeload", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnbeforeload), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnbeforeload) } },
+#if ENABLE(ENCRYPTED_MEDIA)
+    { "onwebkitkeyadded", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitkeyadded), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitkeyadded) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(ENCRYPTED_MEDIA)
+    { "onwebkitkeyerror", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitkeyerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitkeyerror) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(ENCRYPTED_MEDIA)
+    { "onwebkitkeymessage", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitkeymessage), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitkeymessage) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)
+    { "onwebkitneedkey", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitneedkey), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitneedkey) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(VIDEO_PRESENTATION_MODE)
+    { "onwebkitpresentationmodechanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitpresentationmodechanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitpresentationmodechanged) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WIRELESS_PLAYBACK_TARGET)
+    { "onwebkitcurrentplaybacktargetiswirelesschanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitcurrentplaybacktargetiswirelesschanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitcurrentplaybacktargetiswirelesschanged) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WIRELESS_PLAYBACK_TARGET)
+    { "onwebkitplaybacktargetavailabilitychanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitplaybacktargetavailabilitychanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitplaybacktargetavailabilitychanged) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "onabort", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnabort), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnabort) } },
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+    { "onautocomplete", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnautocomplete), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnautocomplete) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+    { "onautocompleteerror", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnautocompleteerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnautocompleteerror) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "onblur", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnblur), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnblur) } },
+    { "oncanplay", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOncanplay), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOncanplay) } },
+    { "oncanplaythrough", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOncanplaythrough), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOncanplaythrough) } },
+    { "onchange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnchange) } },
+    { "onclick", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnclick), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnclick) } },
+    { "oncontextmenu", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOncontextmenu), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOncontextmenu) } },
+    { "ondblclick", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOndblclick), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOndblclick) } },
+    { "ondrag", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOndrag), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOndrag) } },
+    { "ondragend", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOndragend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOndragend) } },
+    { "ondragenter", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOndragenter), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOndragenter) } },
+    { "ondragleave", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOndragleave), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOndragleave) } },
+    { "ondragover", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOndragover), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOndragover) } },
+    { "ondragstart", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOndragstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOndragstart) } },
+    { "ondrop", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOndrop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOndrop) } },
+    { "ondurationchange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOndurationchange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOndurationchange) } },
+    { "onemptied", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnemptied), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnemptied) } },
+    { "onended", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnended), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnended) } },
+    { "onerror", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnerror), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnerror) } },
+    { "onfocus", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnfocus), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnfocus) } },
+    { "oninput", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOninput), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOninput) } },
+    { "oninvalid", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOninvalid), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOninvalid) } },
+    { "onkeydown", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnkeydown), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnkeydown) } },
+    { "onkeypress", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnkeypress), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnkeypress) } },
+    { "onkeyup", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnkeyup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnkeyup) } },
+    { "onload", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnload), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnload) } },
+    { "onloadeddata", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnloadeddata), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnloadeddata) } },
+    { "onloadedmetadata", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnloadedmetadata), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnloadedmetadata) } },
+    { "onloadstart", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnloadstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnloadstart) } },
+    { "onmousedown", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnmousedown), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnmousedown) } },
+    { "onmouseenter", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnmouseenter), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnmouseenter) } },
+    { "onmouseleave", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnmouseleave), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnmouseleave) } },
+    { "onmousemove", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnmousemove), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnmousemove) } },
+    { "onmouseout", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnmouseout), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnmouseout) } },
+    { "onmouseover", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnmouseover), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnmouseover) } },
+    { "onmouseup", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnmouseup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnmouseup) } },
+    { "onmousewheel", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnmousewheel), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnmousewheel) } },
+    { "onpause", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnpause), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnpause) } },
+    { "onplay", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnplay), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnplay) } },
+    { "onplaying", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnplaying), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnplaying) } },
+    { "onprogress", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnprogress), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnprogress) } },
+    { "onratechange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnratechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnratechange) } },
+    { "onreset", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnreset), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnreset) } },
+    { "onresize", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnresize), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnresize) } },
+    { "onscroll", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnscroll), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnscroll) } },
+    { "onseeked", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnseeked), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnseeked) } },
+    { "onseeking", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnseeking), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnseeking) } },
+    { "onselect", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnselect), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnselect) } },
+    { "onstalled", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnstalled), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnstalled) } },
+    { "onsubmit", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnsubmit), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnsubmit) } },
+    { "onsuspend", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnsuspend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnsuspend) } },
+    { "ontimeupdate", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOntimeupdate), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOntimeupdate) } },
+    { "onvolumechange", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnvolumechange), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnvolumechange) } },
+    { "onwaiting", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwaiting), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwaiting) } },
+    { "onsearch", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnsearch), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnsearch) } },
+    { "onwheel", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwheel), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwheel) } },
+#if ENABLE(TOUCH_EVENTS)
+    { "ontouchcancel", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOntouchcancel), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOntouchcancel) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(TOUCH_EVENTS)
+    { "ontouchend", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOntouchend), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOntouchend) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(TOUCH_EVENTS)
+    { "ontouchmove", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOntouchmove), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOntouchmove) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(TOUCH_EVENTS)
+    { "ontouchstart", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOntouchstart), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOntouchstart) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+    { "onwebkitmouseforcechanged", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitmouseforcechanged), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitmouseforcechanged) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+    { "onwebkitmouseforcedown", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitmouseforcedown), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitmouseforcedown) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+    { "onwebkitmouseforcewillbegin", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitmouseforcewillbegin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitmouseforcewillbegin) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(MOUSE_FORCE_EVENTS)
+    { "onwebkitmouseforceup", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitmouseforceup), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitmouseforceup) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+    { "onwebkitwillrevealbottom", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitwillrevealbottom), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitwillrevealbottom) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+    { "onwebkitwillrevealleft", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitwillrevealleft), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitwillrevealleft) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+    { "onwebkitwillrevealright", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitwillrevealright), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitwillrevealright) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+    { "onwebkitwillrevealtop", DontEnum | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementOnwebkitwillrevealtop), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSElementOnwebkitwillrevealtop) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "previousElementSibling", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementPreviousElementSibling), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "nextElementSibling", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementNextElementSibling), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+#if ENABLE(SHADOW_DOM)
+    { "assignedSlot", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementAssignedSlot), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "children", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementChildren), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "firstElementChild", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementFirstElementChild), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "lastElementChild", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementLastElementChild), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "childElementCount", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsElementChildElementCount), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "getAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttribute), (intptr_t) (0) } },
+    { "setAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttribute), (intptr_t) (0) } },
+    { "removeAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemoveAttribute), (intptr_t) (0) } },
+    { "getAttributeNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNode), (intptr_t) (0) } },
+    { "setAttributeNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttributeNode), (intptr_t) (0) } },
+    { "removeAttributeNode", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemoveAttributeNode), (intptr_t) (0) } },
+    { "getElementsByTagName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetElementsByTagName), (intptr_t) (0) } },
+    { "hasAttributes", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionHasAttributes), (intptr_t) (0) } },
+    { "getAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNS), (intptr_t) (0) } },
+    { "setAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttributeNS), (intptr_t) (0) } },
+    { "removeAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemoveAttributeNS), (intptr_t) (2) } },
+    { "getElementsByTagNameNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetElementsByTagNameNS), (intptr_t) (0) } },
+    { "getAttributeNodeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNodeNS), (intptr_t) (0) } },
+    { "setAttributeNodeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionSetAttributeNodeNS), (intptr_t) (0) } },
+    { "hasAttribute", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionHasAttribute), (intptr_t) (1) } },
+    { "hasAttributeNS", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionHasAttributeNS), (intptr_t) (0) } },
+    { "focus", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionFocus), (intptr_t) (0) } },
+    { "blur", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionBlur), (intptr_t) (0) } },
+    { "scrollIntoView", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollIntoView), (intptr_t) (0) } },
+    { "getAttributeNames", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetAttributeNames), (intptr_t) (0) } },
+    { "scrollIntoViewIfNeeded", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollIntoViewIfNeeded), (intptr_t) (0) } },
+    { "scrollByLines", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollByLines), (intptr_t) (0) } },
+    { "scrollByPages", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionScrollByPages), (intptr_t) (0) } },
+    { "getElementsByClassName", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetElementsByClassName), (intptr_t) (0) } },
+    { "matches", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionMatches), (intptr_t) (1) } },
+    { "closest", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionClosest), (intptr_t) (1) } },
+    { "webkitMatchesSelector", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitMatchesSelector), (intptr_t) (1) } },
+    { "getClientRects", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetClientRects), (intptr_t) (0) } },
+    { "getBoundingClientRect", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionGetBoundingClientRect), (intptr_t) (0) } },
+    { "webkitRequestFullScreen", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitRequestFullScreen), (intptr_t) (0) } },
+    { "webkitRequestFullscreen", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitRequestFullscreen), (intptr_t) (0) } },
+#if ENABLE(POINTER_LOCK)
+    { "requestPointerLock", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRequestPointerLock), (intptr_t) (0) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(CSS_REGIONS)
+    { "webkitGetRegionFlowRanges", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionWebkitGetRegionFlowRanges), (intptr_t) (0) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+#if ENABLE(SHADOW_DOM)
+    { "attachShadow", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionAttachShadow), (intptr_t) (1) } },
+#else
+    { 0, 0, NoIntrinsic, { 0, 0 } },
+#endif
+    { "before", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionBefore), (intptr_t) (0) } },
+    { "after", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionAfter), (intptr_t) (0) } },
+    { "replaceWith", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionReplaceWith), (intptr_t) (0) } },
+    { "remove", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionRemove), (intptr_t) (0) } },
+    { "prepend", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionPrepend), (intptr_t) (0) } },
+    { "append", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionAppend), (intptr_t) (0) } },
+    { "querySelector", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionQuerySelector), (intptr_t) (1) } },
+    { "querySelectorAll", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsElementPrototypeFunctionQuerySelectorAll), (intptr_t) (1) } },
+    { "ALLOW_KEYBOARD_INPUT", DontDelete | ReadOnly | ConstantInteger, NoIntrinsic, { (long long)(1) } },
+};
+
+const ClassInfo JSElementPrototype::s_info = { "ElementPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSElementPrototype) };
+
+void JSElementPrototype::finishCreation(VM& vm)
+{
+    Base::finishCreation(vm);
+    reifyStaticProperties(vm, JSElementPrototypeTableValues, *this);
+}
+
+const ClassInfo JSElement::s_info = { "Element", &Base::s_info, 0, CREATE_METHOD_TABLE(JSElement) };
+
+JSElement::JSElement(Structure* structure, JSDOMGlobalObject& globalObject, Ref<Element>&& impl)
+    : JSNode(structure, globalObject, WTFMove(impl))
+{
+}
+
+JSObject* JSElement::createPrototype(VM& vm, JSGlobalObject* globalObject)
+{
+    return JSElementPrototype::create(vm, globalObject, JSElementPrototype::createStructure(vm, globalObject, JSNode::getPrototype(vm, globalObject)));
+}
+
+JSObject* JSElement::getPrototype(VM& vm, JSGlobalObject* globalObject)
+{
+    return getDOMPrototype<JSElement>(vm, globalObject);
+}
+
+EncodedJSValue jsElementTagName(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "tagName");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringOrNull(state, impl.tagName());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementAttributes(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "attributes");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.attributes()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementStyle(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "style");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.cssomStyle()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementId(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "id");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.getIdAttribute());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementOffsetLeft(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "offsetLeft");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.offsetLeft());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementOffsetTop(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "offsetTop");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.offsetTop());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementOffsetWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "offsetWidth");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.offsetWidth());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementOffsetHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "offsetHeight");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.offsetHeight());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementClientLeft(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "clientLeft");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.clientLeft());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementClientTop(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "clientTop");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.clientTop());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementClientWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "clientWidth");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.clientWidth());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementClientHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "clientHeight");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.clientHeight());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementScrollLeft(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "scrollLeft");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.scrollLeft());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementScrollTop(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "scrollTop");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.scrollTop());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementScrollWidth(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "scrollWidth");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.scrollWidth());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementScrollHeight(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "scrollHeight");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.scrollHeight());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementOffsetParent(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "offsetParent");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.bindingsOffsetParent()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementInnerHTML(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "innerHTML");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.innerHTML());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementOuterHTML(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "outerHTML");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.outerHTML());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementClassName(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "className");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.fastGetAttribute(WebCore::HTMLNames::classAttr));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementClassList(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "classList");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.classList()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementDataset(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "dataset");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.dataset()));
+    return JSValue::encode(result);
+}
+
+
+#if ENABLE(CSS_REGIONS)
+EncodedJSValue jsElementWebkitRegionOverset(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "webkitRegionOverset");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.webkitRegionOverset());
+    return JSValue::encode(result);
+}
+
+#endif
+
+#if ENABLE(SHADOW_DOM)
+EncodedJSValue jsElementShadowRoot(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "shadowRoot");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.shadowRootForBindings(*state)));
+    return JSValue::encode(result);
+}
+
+#endif
+
+#if ENABLE(SHADOW_DOM)
+EncodedJSValue jsElementSlot(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "slot");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.fastGetAttribute(WebCore::HTMLNames::slotAttr));
+    return JSValue::encode(result);
+}
+
+#endif
+
+EncodedJSValue jsElementOnbeforecopy(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onbeforecopy");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforecopyEvent));
+}
+
+
+EncodedJSValue jsElementOnbeforecut(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onbeforecut");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforecutEvent));
+}
+
+
+EncodedJSValue jsElementOnbeforepaste(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onbeforepaste");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforepasteEvent));
+}
+
+
+EncodedJSValue jsElementOncopy(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "oncopy");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().copyEvent));
+}
+
+
+EncodedJSValue jsElementOncut(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "oncut");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().cutEvent));
+}
+
+
+EncodedJSValue jsElementOnpaste(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onpaste");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().pasteEvent));
+}
+
+
+EncodedJSValue jsElementOnselectstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onselectstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().selectstartEvent));
+}
+
+
+#if ENABLE(FULLSCREEN_API)
+EncodedJSValue jsElementOnwebkitfullscreenchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitfullscreenchange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitfullscreenchangeEvent));
+}
+
+#endif
+
+#if ENABLE(FULLSCREEN_API)
+EncodedJSValue jsElementOnwebkitfullscreenerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitfullscreenerror");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitfullscreenerrorEvent));
+}
+
+#endif
+
+EncodedJSValue jsElementOnanimationend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onanimationend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().animationendEvent));
+}
+
+
+EncodedJSValue jsElementOnanimationiteration(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onanimationiteration");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().animationiterationEvent));
+}
+
+
+EncodedJSValue jsElementOnanimationstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onanimationstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().animationstartEvent));
+}
+
+
+EncodedJSValue jsElementOntransitionend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ontransitionend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().transitionendEvent));
+}
+
+
+EncodedJSValue jsElementOnwebkitanimationend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitanimationend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitAnimationEndEvent));
+}
+
+
+EncodedJSValue jsElementOnwebkitanimationiteration(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitanimationiteration");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitAnimationIterationEvent));
+}
+
+
+EncodedJSValue jsElementOnwebkitanimationstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitanimationstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitAnimationStartEvent));
+}
+
+
+EncodedJSValue jsElementOnwebkittransitionend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkittransitionend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitTransitionEndEvent));
+}
+
+
+#if ENABLE(IOS_GESTURE_EVENTS)
+EncodedJSValue jsElementOngesturechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ongesturechange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().gesturechangeEvent));
+}
+
+#endif
+
+#if ENABLE(IOS_GESTURE_EVENTS)
+EncodedJSValue jsElementOngestureend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ongestureend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().gestureendEvent));
+}
+
+#endif
+
+#if ENABLE(IOS_GESTURE_EVENTS)
+EncodedJSValue jsElementOngesturestart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ongesturestart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().gesturestartEvent));
+}
+
+#endif
+
+EncodedJSValue jsElementOnfocusin(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onfocusin");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().focusinEvent));
+}
+
+
+EncodedJSValue jsElementOnfocusout(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onfocusout");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().focusoutEvent));
+}
+
+
+EncodedJSValue jsElementOnbeforeload(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onbeforeload");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().beforeloadEvent));
+}
+
+
+#if ENABLE(ENCRYPTED_MEDIA)
+EncodedJSValue jsElementOnwebkitkeyadded(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitkeyadded");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitkeyaddedEvent));
+}
+
+#endif
+
+#if ENABLE(ENCRYPTED_MEDIA)
+EncodedJSValue jsElementOnwebkitkeyerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitkeyerror");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitkeyerrorEvent));
+}
+
+#endif
+
+#if ENABLE(ENCRYPTED_MEDIA)
+EncodedJSValue jsElementOnwebkitkeymessage(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitkeymessage");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitkeymessageEvent));
+}
+
+#endif
+
+#if ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)
+EncodedJSValue jsElementOnwebkitneedkey(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitneedkey");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitneedkeyEvent));
+}
+
+#endif
+
+#if ENABLE(VIDEO_PRESENTATION_MODE)
+EncodedJSValue jsElementOnwebkitpresentationmodechanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitpresentationmodechanged");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitpresentationmodechangedEvent));
+}
+
+#endif
+
+#if ENABLE(WIRELESS_PLAYBACK_TARGET)
+EncodedJSValue jsElementOnwebkitcurrentplaybacktargetiswirelesschanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitcurrentplaybacktargetiswirelesschanged");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent));
+}
+
+#endif
+
+#if ENABLE(WIRELESS_PLAYBACK_TARGET)
+EncodedJSValue jsElementOnwebkitplaybacktargetavailabilitychanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitplaybacktargetavailabilitychanged");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitplaybacktargetavailabilitychangedEvent));
+}
+
+#endif
+
+EncodedJSValue jsElementOnabort(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onabort");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().abortEvent));
+}
+
+
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+EncodedJSValue jsElementOnautocomplete(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onautocomplete");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().autocompleteEvent));
+}
+
+#endif
+
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+EncodedJSValue jsElementOnautocompleteerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onautocompleteerror");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().autocompleteerrorEvent));
+}
+
+#endif
+
+EncodedJSValue jsElementOnblur(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onblur");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().blurEvent));
+}
+
+
+EncodedJSValue jsElementOncanplay(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "oncanplay");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().canplayEvent));
+}
+
+
+EncodedJSValue jsElementOncanplaythrough(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "oncanplaythrough");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().canplaythroughEvent));
+}
+
+
+EncodedJSValue jsElementOnchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onchange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().changeEvent));
+}
+
+
+EncodedJSValue jsElementOnclick(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onclick");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().clickEvent));
+}
+
+
+EncodedJSValue jsElementOncontextmenu(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "oncontextmenu");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().contextmenuEvent));
+}
+
+
+EncodedJSValue jsElementOndblclick(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ondblclick");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dblclickEvent));
+}
+
+
+EncodedJSValue jsElementOndrag(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ondrag");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragEvent));
+}
+
+
+EncodedJSValue jsElementOndragend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ondragend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragendEvent));
+}
+
+
+EncodedJSValue jsElementOndragenter(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ondragenter");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragenterEvent));
+}
+
+
+EncodedJSValue jsElementOndragleave(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ondragleave");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragleaveEvent));
+}
+
+
+EncodedJSValue jsElementOndragover(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ondragover");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragoverEvent));
+}
+
+
+EncodedJSValue jsElementOndragstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ondragstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dragstartEvent));
+}
+
+
+EncodedJSValue jsElementOndrop(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ondrop");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().dropEvent));
+}
+
+
+EncodedJSValue jsElementOndurationchange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ondurationchange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().durationchangeEvent));
+}
+
+
+EncodedJSValue jsElementOnemptied(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onemptied");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().emptiedEvent));
+}
+
+
+EncodedJSValue jsElementOnended(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onended");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().endedEvent));
+}
+
+
+EncodedJSValue jsElementOnerror(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onerror");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().errorEvent));
+}
+
+
+EncodedJSValue jsElementOnfocus(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onfocus");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().focusEvent));
+}
+
+
+EncodedJSValue jsElementOninput(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "oninput");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().inputEvent));
+}
+
+
+EncodedJSValue jsElementOninvalid(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "oninvalid");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().invalidEvent));
+}
+
+
+EncodedJSValue jsElementOnkeydown(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onkeydown");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().keydownEvent));
+}
+
+
+EncodedJSValue jsElementOnkeypress(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onkeypress");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().keypressEvent));
+}
+
+
+EncodedJSValue jsElementOnkeyup(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onkeyup");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().keyupEvent));
+}
+
+
+EncodedJSValue jsElementOnload(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onload");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadEvent));
+}
+
+
+EncodedJSValue jsElementOnloadeddata(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onloadeddata");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadeddataEvent));
+}
+
+
+EncodedJSValue jsElementOnloadedmetadata(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onloadedmetadata");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadedmetadataEvent));
+}
+
+
+EncodedJSValue jsElementOnloadstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onloadstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().loadstartEvent));
+}
+
+
+EncodedJSValue jsElementOnmousedown(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onmousedown");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mousedownEvent));
+}
+
+
+EncodedJSValue jsElementOnmouseenter(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return JSValue::encode(jsUndefined());
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseenterEvent));
+}
+
+
+EncodedJSValue jsElementOnmouseleave(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return JSValue::encode(jsUndefined());
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseleaveEvent));
+}
+
+
+EncodedJSValue jsElementOnmousemove(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onmousemove");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mousemoveEvent));
+}
+
+
+EncodedJSValue jsElementOnmouseout(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onmouseout");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseoutEvent));
+}
+
+
+EncodedJSValue jsElementOnmouseover(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onmouseover");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseoverEvent));
+}
+
+
+EncodedJSValue jsElementOnmouseup(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onmouseup");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mouseupEvent));
+}
+
+
+EncodedJSValue jsElementOnmousewheel(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onmousewheel");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().mousewheelEvent));
+}
+
+
+EncodedJSValue jsElementOnpause(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onpause");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().pauseEvent));
+}
+
+
+EncodedJSValue jsElementOnplay(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onplay");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().playEvent));
+}
+
+
+EncodedJSValue jsElementOnplaying(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onplaying");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().playingEvent));
+}
+
+
+EncodedJSValue jsElementOnprogress(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onprogress");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().progressEvent));
+}
+
+
+EncodedJSValue jsElementOnratechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onratechange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().ratechangeEvent));
+}
+
+
+EncodedJSValue jsElementOnreset(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onreset");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().resetEvent));
+}
+
+
+EncodedJSValue jsElementOnresize(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onresize");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().resizeEvent));
+}
+
+
+EncodedJSValue jsElementOnscroll(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onscroll");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().scrollEvent));
+}
+
+
+EncodedJSValue jsElementOnseeked(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onseeked");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().seekedEvent));
+}
+
+
+EncodedJSValue jsElementOnseeking(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onseeking");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().seekingEvent));
+}
+
+
+EncodedJSValue jsElementOnselect(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onselect");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().selectEvent));
+}
+
+
+EncodedJSValue jsElementOnstalled(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onstalled");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().stalledEvent));
+}
+
+
+EncodedJSValue jsElementOnsubmit(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onsubmit");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().submitEvent));
+}
+
+
+EncodedJSValue jsElementOnsuspend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onsuspend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().suspendEvent));
+}
+
+
+EncodedJSValue jsElementOntimeupdate(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ontimeupdate");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().timeupdateEvent));
+}
+
+
+EncodedJSValue jsElementOnvolumechange(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onvolumechange");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().volumechangeEvent));
+}
+
+
+EncodedJSValue jsElementOnwaiting(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwaiting");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().waitingEvent));
+}
+
+
+EncodedJSValue jsElementOnsearch(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onsearch");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().searchEvent));
+}
+
+
+EncodedJSValue jsElementOnwheel(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwheel");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().wheelEvent));
+}
+
+
+#if ENABLE(TOUCH_EVENTS)
+EncodedJSValue jsElementOntouchcancel(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ontouchcancel");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchcancelEvent));
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+EncodedJSValue jsElementOntouchend(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ontouchend");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchendEvent));
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+EncodedJSValue jsElementOntouchmove(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ontouchmove");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchmoveEvent));
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+EncodedJSValue jsElementOntouchstart(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "ontouchstart");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().touchstartEvent));
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+EncodedJSValue jsElementOnwebkitmouseforcechanged(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitmouseforcechanged");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforcechangedEvent));
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+EncodedJSValue jsElementOnwebkitmouseforcedown(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitmouseforcedown");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforcedownEvent));
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+EncodedJSValue jsElementOnwebkitmouseforcewillbegin(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitmouseforcewillbegin");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforcewillbeginEvent));
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+EncodedJSValue jsElementOnwebkitmouseforceup(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitmouseforceup");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitmouseforceupEvent));
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+EncodedJSValue jsElementOnwebkitwillrevealbottom(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitwillrevealbottom");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealbottomEvent));
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+EncodedJSValue jsElementOnwebkitwillrevealleft(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitwillrevealleft");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealleftEvent));
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+EncodedJSValue jsElementOnwebkitwillrevealright(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitwillrevealright");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealrightEvent));
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+EncodedJSValue jsElementOnwebkitwillrevealtop(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "onwebkitwillrevealtop");
+    }
+    UNUSED_PARAM(state);
+    return JSValue::encode(eventHandlerAttribute(castedThis->wrapped(), eventNames().webkitwillrevealtopEvent));
+}
+
+#endif
+
+EncodedJSValue jsElementPreviousElementSibling(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "previousElementSibling");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.previousElementSibling()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementNextElementSibling(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "nextElementSibling");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.nextElementSibling()));
+    return JSValue::encode(result);
+}
+
+
+#if ENABLE(SHADOW_DOM)
+EncodedJSValue jsElementAssignedSlot(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "assignedSlot");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.assignedSlot()));
+    return JSValue::encode(result);
+}
+
+#endif
+
+EncodedJSValue jsElementChildren(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "children");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.children()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementFirstElementChild(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "firstElementChild");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.firstElementChild()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementLastElementChild(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "lastElementChild");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.lastElementChild()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementChildElementCount(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsElementCast(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Element", "childElementCount");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.childElementCount());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsElementConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    JSElementPrototype* domObject = jsDynamicCast<JSElementPrototype*>(JSValue::decode(thisValue));
+    if (!domObject)
+        return throwVMTypeError(state);
+    return JSValue::encode(JSElement::getConstructor(state->vm(), domObject->globalObject()));
+}
+
+void setJSElementConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    JSElementPrototype* domObject = jsDynamicCast<JSElementPrototype*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!domObject)) {
+        throwVMTypeError(state);
+        return;
+    }
+    // Shadowing a built-in constructor
+    domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
+}
+
+void setJSElementId(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "id");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::idAttr, nativeValue);
+}
+
+
+void setJSElementScrollLeft(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "scrollLeft");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    int nativeValue = toInt32(state, value, NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setScrollLeft(nativeValue);
+}
+
+
+void setJSElementScrollTop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "scrollTop");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    int nativeValue = toInt32(state, value, NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setScrollTop(nativeValue);
+}
+
+
+void setJSElementInnerHTML(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "innerHTML");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setInnerHTML(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSElementOuterHTML(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "outerHTML");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setOuterHTML(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSElementClassName(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "className");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::classAttr, nativeValue);
+}
+
+
+void setJSElementClassList(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "classList");
+        return;
+    }
+    Ref<DOMTokenList> forwardedImpl = castedThis->wrapped().classList();
+    auto& impl = forwardedImpl.get();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setValue(nativeValue);
+}
+
+
+#if ENABLE(SHADOW_DOM)
+void setJSElementSlot(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "slot");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::slotAttr, nativeValue);
+}
+
+#endif
+
+void setJSElementOnbeforecopy(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onbeforecopy");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforecopyEvent, value);
+}
+
+
+void setJSElementOnbeforecut(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onbeforecut");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforecutEvent, value);
+}
+
+
+void setJSElementOnbeforepaste(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onbeforepaste");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforepasteEvent, value);
+}
+
+
+void setJSElementOncopy(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "oncopy");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().copyEvent, value);
+}
+
+
+void setJSElementOncut(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "oncut");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().cutEvent, value);
+}
+
+
+void setJSElementOnpaste(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onpaste");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().pasteEvent, value);
+}
+
+
+void setJSElementOnselectstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onselectstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().selectstartEvent, value);
+}
+
+
+#if ENABLE(FULLSCREEN_API)
+void setJSElementOnwebkitfullscreenchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitfullscreenchange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitfullscreenchangeEvent, value);
+}
+
+#endif
+
+#if ENABLE(FULLSCREEN_API)
+void setJSElementOnwebkitfullscreenerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitfullscreenerror");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitfullscreenerrorEvent, value);
+}
+
+#endif
+
+void setJSElementOnanimationend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onanimationend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().animationendEvent, value);
+}
+
+
+void setJSElementOnanimationiteration(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onanimationiteration");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().animationiterationEvent, value);
+}
+
+
+void setJSElementOnanimationstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onanimationstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().animationstartEvent, value);
+}
+
+
+void setJSElementOntransitionend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ontransitionend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().transitionendEvent, value);
+}
+
+
+void setJSElementOnwebkitanimationend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitanimationend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitAnimationEndEvent, value);
+}
+
+
+void setJSElementOnwebkitanimationiteration(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitanimationiteration");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitAnimationIterationEvent, value);
+}
+
+
+void setJSElementOnwebkitanimationstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitanimationstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitAnimationStartEvent, value);
+}
+
+
+void setJSElementOnwebkittransitionend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkittransitionend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitTransitionEndEvent, value);
+}
+
+
+#if ENABLE(IOS_GESTURE_EVENTS)
+void setJSElementOngesturechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ongesturechange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().gesturechangeEvent, value);
+}
+
+#endif
+
+#if ENABLE(IOS_GESTURE_EVENTS)
+void setJSElementOngestureend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ongestureend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().gestureendEvent, value);
+}
+
+#endif
+
+#if ENABLE(IOS_GESTURE_EVENTS)
+void setJSElementOngesturestart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ongesturestart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().gesturestartEvent, value);
+}
+
+#endif
+
+void setJSElementOnfocusin(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onfocusin");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().focusinEvent, value);
+}
+
+
+void setJSElementOnfocusout(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onfocusout");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().focusoutEvent, value);
+}
+
+
+void setJSElementOnbeforeload(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onbeforeload");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().beforeloadEvent, value);
+}
+
+
+#if ENABLE(ENCRYPTED_MEDIA)
+void setJSElementOnwebkitkeyadded(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitkeyadded");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitkeyaddedEvent, value);
+}
+
+#endif
+
+#if ENABLE(ENCRYPTED_MEDIA)
+void setJSElementOnwebkitkeyerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitkeyerror");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitkeyerrorEvent, value);
+}
+
+#endif
+
+#if ENABLE(ENCRYPTED_MEDIA)
+void setJSElementOnwebkitkeymessage(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitkeymessage");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitkeymessageEvent, value);
+}
+
+#endif
+
+#if ENABLE(ENCRYPTED_MEDIA) || ENABLE(ENCRYPTED_MEDIA_V2)
+void setJSElementOnwebkitneedkey(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitneedkey");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitneedkeyEvent, value);
+}
+
+#endif
+
+#if ENABLE(VIDEO_PRESENTATION_MODE)
+void setJSElementOnwebkitpresentationmodechanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitpresentationmodechanged");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitpresentationmodechangedEvent, value);
+}
+
+#endif
+
+#if ENABLE(WIRELESS_PLAYBACK_TARGET)
+void setJSElementOnwebkitcurrentplaybacktargetiswirelesschanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitcurrentplaybacktargetiswirelesschanged");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, value);
+}
+
+#endif
+
+#if ENABLE(WIRELESS_PLAYBACK_TARGET)
+void setJSElementOnwebkitplaybacktargetavailabilitychanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitplaybacktargetavailabilitychanged");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitplaybacktargetavailabilitychangedEvent, value);
+}
+
+#endif
+
+void setJSElementOnabort(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onabort");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().abortEvent, value);
+}
+
+
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+void setJSElementOnautocomplete(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onautocomplete");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().autocompleteEvent, value);
+}
+
+#endif
+
+#if ENABLE(REQUEST_AUTOCOMPLETE)
+void setJSElementOnautocompleteerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onautocompleteerror");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().autocompleteerrorEvent, value);
+}
+
+#endif
+
+void setJSElementOnblur(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onblur");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().blurEvent, value);
+}
+
+
+void setJSElementOncanplay(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "oncanplay");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().canplayEvent, value);
+}
+
+
+void setJSElementOncanplaythrough(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "oncanplaythrough");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().canplaythroughEvent, value);
+}
+
+
+void setJSElementOnchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onchange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().changeEvent, value);
+}
+
+
+void setJSElementOnclick(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onclick");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().clickEvent, value);
+}
+
+
+void setJSElementOncontextmenu(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "oncontextmenu");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().contextmenuEvent, value);
+}
+
+
+void setJSElementOndblclick(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ondblclick");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dblclickEvent, value);
+}
+
+
+void setJSElementOndrag(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ondrag");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragEvent, value);
+}
+
+
+void setJSElementOndragend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ondragend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragendEvent, value);
+}
+
+
+void setJSElementOndragenter(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ondragenter");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragenterEvent, value);
+}
+
+
+void setJSElementOndragleave(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ondragleave");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragleaveEvent, value);
+}
+
+
+void setJSElementOndragover(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ondragover");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragoverEvent, value);
+}
+
+
+void setJSElementOndragstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ondragstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dragstartEvent, value);
+}
+
+
+void setJSElementOndrop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ondrop");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().dropEvent, value);
+}
+
+
+void setJSElementOndurationchange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ondurationchange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().durationchangeEvent, value);
+}
+
+
+void setJSElementOnemptied(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onemptied");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().emptiedEvent, value);
+}
+
+
+void setJSElementOnended(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onended");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().endedEvent, value);
+}
+
+
+void setJSElementOnerror(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onerror");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().errorEvent, value);
+}
+
+
+void setJSElementOnfocus(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onfocus");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().focusEvent, value);
+}
+
+
+void setJSElementOninput(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "oninput");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().inputEvent, value);
+}
+
+
+void setJSElementOninvalid(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "oninvalid");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().invalidEvent, value);
+}
+
+
+void setJSElementOnkeydown(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onkeydown");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().keydownEvent, value);
+}
+
+
+void setJSElementOnkeypress(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onkeypress");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().keypressEvent, value);
+}
+
+
+void setJSElementOnkeyup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onkeyup");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().keyupEvent, value);
+}
+
+
+void setJSElementOnload(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onload");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadEvent, value);
+}
+
+
+void setJSElementOnloadeddata(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onloadeddata");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadeddataEvent, value);
+}
+
+
+void setJSElementOnloadedmetadata(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onloadedmetadata");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadedmetadataEvent, value);
+}
+
+
+void setJSElementOnloadstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onloadstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().loadstartEvent, value);
+}
+
+
+void setJSElementOnmousedown(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onmousedown");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mousedownEvent, value);
+}
+
+
+void setJSElementOnmouseenter(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseenterEvent, value);
+}
+
+
+void setJSElementOnmouseleave(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseleaveEvent, value);
+}
+
+
+void setJSElementOnmousemove(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onmousemove");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mousemoveEvent, value);
+}
+
+
+void setJSElementOnmouseout(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onmouseout");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseoutEvent, value);
+}
+
+
+void setJSElementOnmouseover(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onmouseover");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseoverEvent, value);
+}
+
+
+void setJSElementOnmouseup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onmouseup");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mouseupEvent, value);
+}
+
+
+void setJSElementOnmousewheel(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onmousewheel");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().mousewheelEvent, value);
+}
+
+
+void setJSElementOnpause(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onpause");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().pauseEvent, value);
+}
+
+
+void setJSElementOnplay(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onplay");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().playEvent, value);
+}
+
+
+void setJSElementOnplaying(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onplaying");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().playingEvent, value);
+}
+
+
+void setJSElementOnprogress(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onprogress");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().progressEvent, value);
+}
+
+
+void setJSElementOnratechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onratechange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().ratechangeEvent, value);
+}
+
+
+void setJSElementOnreset(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onreset");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().resetEvent, value);
+}
+
+
+void setJSElementOnresize(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onresize");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().resizeEvent, value);
+}
+
+
+void setJSElementOnscroll(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onscroll");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().scrollEvent, value);
+}
+
+
+void setJSElementOnseeked(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onseeked");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().seekedEvent, value);
+}
+
+
+void setJSElementOnseeking(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onseeking");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().seekingEvent, value);
+}
+
+
+void setJSElementOnselect(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onselect");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().selectEvent, value);
+}
+
+
+void setJSElementOnstalled(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onstalled");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().stalledEvent, value);
+}
+
+
+void setJSElementOnsubmit(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onsubmit");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().submitEvent, value);
+}
+
+
+void setJSElementOnsuspend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onsuspend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().suspendEvent, value);
+}
+
+
+void setJSElementOntimeupdate(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ontimeupdate");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().timeupdateEvent, value);
+}
+
+
+void setJSElementOnvolumechange(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onvolumechange");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().volumechangeEvent, value);
+}
+
+
+void setJSElementOnwaiting(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwaiting");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().waitingEvent, value);
+}
+
+
+void setJSElementOnsearch(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onsearch");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().searchEvent, value);
+}
+
+
+void setJSElementOnwheel(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwheel");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().wheelEvent, value);
+}
+
+
+#if ENABLE(TOUCH_EVENTS)
+void setJSElementOntouchcancel(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ontouchcancel");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchcancelEvent, value);
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+void setJSElementOntouchend(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ontouchend");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchendEvent, value);
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+void setJSElementOntouchmove(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ontouchmove");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchmoveEvent, value);
+}
+
+#endif
+
+#if ENABLE(TOUCH_EVENTS)
+void setJSElementOntouchstart(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "ontouchstart");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().touchstartEvent, value);
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+void setJSElementOnwebkitmouseforcechanged(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitmouseforcechanged");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforcechangedEvent, value);
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+void setJSElementOnwebkitmouseforcedown(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitmouseforcedown");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforcedownEvent, value);
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+void setJSElementOnwebkitmouseforcewillbegin(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitmouseforcewillbegin");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforcewillbeginEvent, value);
+}
+
+#endif
+
+#if ENABLE(MOUSE_FORCE_EVENTS)
+void setJSElementOnwebkitmouseforceup(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitmouseforceup");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitmouseforceupEvent, value);
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+void setJSElementOnwebkitwillrevealbottom(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitwillrevealbottom");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealbottomEvent, value);
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+void setJSElementOnwebkitwillrevealleft(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitwillrevealleft");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealleftEvent, value);
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+void setJSElementOnwebkitwillrevealright(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitwillrevealright");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealrightEvent, value);
+}
+
+#endif
+
+#if ENABLE(WILL_REVEAL_EDGE_EVENTS)
+void setJSElementOnwebkitwillrevealtop(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSElement* castedThis = jsElementCast(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Element", "onwebkitwillrevealtop");
+        return;
+    }
+    setEventHandlerAttribute(*state, *castedThis, castedThis->wrapped(), eventNames().webkitwillrevealtopEvent, value);
+}
+
+#endif
+
+JSValue JSElement::getConstructor(VM& vm, const JSGlobalObject* globalObject)
+{
+    return getDOMConstructor<JSElementConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttribute(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getAttribute");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    String name = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsStringOrNull(state, impl.getAttribute(name));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttribute(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "setAttribute");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String name = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String value = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+
+    if(cTaintLog::isDOM_XSS()) {
+      //if(!MAYBE_MISSING_PARAMETER(state, 1, DefaultIsUndefined).isEmpty()) {
+        JSValue val =  state->argument(1);
+        JSString* strPtr = val.toString(state);
+        unsigned int id = rand();
+        cTaintLog::add_taint_log(strPtr->__dxx_source(state), "element.setAttribute", strPtr->__dxx_taint(state), id, 0, true);
+        //std::cout<< "inside element.setAttribute() The taint is: "  << strPtr->taint(exec) << "source is " << (int)strPtr->source(exec) << std::endl;
+      //}
+    }
+
+    impl.setAttribute(name, value, ec);
+    setDOMException(state, ec);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttribute(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "removeAttribute");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    String name = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.removeAttribute(name);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNode(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getAttributeNode");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    String name = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getAttributeNode(name)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNode(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "setAttributeNode");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    Attr* newAttr = JSAttr::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.setAttributeNode(newAttr, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNode(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "removeAttributeNode");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    Attr* oldAttr = JSAttr::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.removeAttributeNode(oldAttr, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagName(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getElementsByTagName");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    String name = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getElementsByTagName(name)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributes(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "hasAttributes");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.hasAttributes());
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getAttributeNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    String namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String localName = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsStringOrNull(state, impl.getAttributeNS(namespaceURI, localName));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "setAttributeNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String qualifiedName = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String value = state->argument(2).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.setAttributeNS(namespaceURI, qualifiedName, value, ec);
+    setDOMException(state, ec);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemoveAttributeNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "removeAttributeNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 2))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    String namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String localName = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.removeAttributeNS(namespaceURI, localName);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByTagNameNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getElementsByTagNameNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    String namespaceURI = valueToStringWithNullCheck(state, state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String localName = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getElementsByTagNameNS(namespaceURI, localName)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNodeNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getAttributeNodeNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    String namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String localName = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getAttributeNodeNS(namespaceURI, localName)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionSetAttributeNodeNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "setAttributeNodeNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    Attr* newAttr = JSAttr::toWrapped(state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.setAttributeNodeNS(newAttr, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttribute(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "hasAttribute");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    String name = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsBoolean(impl.hasAttribute(name));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionHasAttributeNS(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "hasAttributeNS");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    String namespaceURI = valueToStringWithUndefinedOrNullCheck(state, state->argument(0));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String localName = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsBoolean(impl.hasAttributeNS(namespaceURI, localName));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionFocus(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "focus");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    impl.focus();
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionBlur(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "blur");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    impl.blur();
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoView(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "scrollIntoView");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+
+    size_t argsCount = state->argumentCount();
+    if (argsCount <= 0) {
+        impl.scrollIntoView();
+        return JSValue::encode(jsUndefined());
+    }
+
+    bool alignWithTop = state->argument(0).toBoolean(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.scrollIntoView(alignWithTop);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetAttributeNames(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getAttributeNames");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsArray(state, castedThis->globalObject(), impl.getAttributeNames());
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollIntoViewIfNeeded(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "scrollIntoViewIfNeeded");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+
+    size_t argsCount = state->argumentCount();
+    if (argsCount <= 0) {
+        impl.scrollIntoViewIfNeeded();
+        return JSValue::encode(jsUndefined());
+    }
+
+    bool centerIfNeeded = state->argument(0).toBoolean(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.scrollIntoViewIfNeeded(centerIfNeeded);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByLines(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "scrollByLines");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    int lines = toInt32(state, state->argument(0), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.scrollByLines(lines);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionScrollByPages(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "scrollByPages");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    int pages = toInt32(state, state->argument(0), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.scrollByPages(pages);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetElementsByClassName(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getElementsByClassName");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    String name = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getElementsByClassName(name)));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionMatches(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "matches");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    String selectors = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsBoolean(impl.matches(selectors, ec));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionClosest(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "closest");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    String selectors = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.closest(selectors, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitMatchesSelector(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "webkitMatchesSelector");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    String selectors = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = jsBoolean(impl.matches(selectors, ec));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetClientRects(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getClientRects");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getClientRects()));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionGetBoundingClientRect(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "getBoundingClientRect");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.getBoundingClientRect()));
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullScreen(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "webkitRequestFullScreen");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    uint16_t flags = toUInt16(state, state->argument(0), NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.webkitRequestFullScreen(flags);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitRequestFullscreen(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "webkitRequestFullscreen");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    impl.webkitRequestFullscreen();
+    return JSValue::encode(jsUndefined());
+}
+
+#if ENABLE(POINTER_LOCK)
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRequestPointerLock(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "requestPointerLock");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    impl.requestPointerLock();
+    return JSValue::encode(jsUndefined());
+}
+
+#endif
+
+#if ENABLE(CSS_REGIONS)
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionWebkitGetRegionFlowRanges(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "webkitGetRegionFlowRanges");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsArray(state, castedThis->globalObject(), impl.webkitGetRegionFlowRanges());
+    return JSValue::encode(result);
+}
+
+#endif
+
+#if ENABLE(SHADOW_DOM)
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAttachShadow(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "attachShadow");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    Dictionary options = { state, state->argument(0) };
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.attachShadow(options, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+#endif
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionBefore(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "before");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    return JSValue::encode(castedThis->before(*state));
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAfter(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "after");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    return JSValue::encode(castedThis->after(*state));
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionReplaceWith(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "replaceWith");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    return JSValue::encode(castedThis->replaceWith(*state));
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionRemove(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "remove");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    impl.remove(ec);
+    setDOMException(state, ec);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionPrepend(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "prepend");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    return JSValue::encode(castedThis->prepend(*state));
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionAppend(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "append");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    return JSValue::encode(castedThis->append(*state));
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelector(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "querySelector");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    String selectors = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.querySelector(selectors, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsElementPrototypeFunctionQuerySelectorAll(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsElementCast(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Element", "querySelectorAll");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSElement::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    ExceptionCode ec = 0;
+    String selectors = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJSNewlyCreated(state, castedThis->globalObject(), WTF::getPtr(impl.querySelectorAll(selectors, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+void JSElement::visitChildren(JSCell* cell, SlotVisitor& visitor)
+{
+    auto* thisObject = jsCast<JSElement*>(cell);
+    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
+    Base::visitChildren(thisObject, visitor);
+    thisObject->wrapped().visitJSEventListeners(visitor);
+}
+
+Element* JSElement::toWrapped(JSC::JSValue value)
+{
+    if (auto* wrapper = jsElementCast(value))
+        return &wrapper->wrapped();
+    return nullptr;
+}
+
+}
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/dom_generated/JSHTMLElement.cpp qtwebkit/Source/WebCore/dom_generated/JSHTMLElement.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/dom_generated/JSHTMLElement.cpp	1969-12-31 16:00:00.000000000 -0800
+++ qtwebkit/Source/WebCore/dom_generated/JSHTMLElement.cpp	2018-06-02 13:20:15.031325000 -0700
@@ -0,0 +1,753 @@
+/*
+    This file is part of the WebKit open source project.
+    This file has been generated by generate-bindings.pl. DO NOT MODIFY!
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "config.h"
+#include "JSHTMLElement.h"
+
+#include "Element.h"
+#include "ExceptionCode.h"
+#include "HTMLNames.h"
+#include "JSDOMBinding.h"
+#include "JSDOMConstructor.h"
+#include "JSElement.h"
+#include "URL.h"
+#include <runtime/Error.h>
+#include <runtime/JSString.h>
+#include <wtf/GetPtr.h>
+
+using namespace JSC;
+
+namespace WebCore {
+
+// Functions
+
+JSC::EncodedJSValue JSC_HOST_CALL jsHTMLElementPrototypeFunctionInsertAdjacentElement(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsHTMLElementPrototypeFunctionInsertAdjacentHTML(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsHTMLElementPrototypeFunctionInsertAdjacentText(JSC::ExecState*);
+JSC::EncodedJSValue JSC_HOST_CALL jsHTMLElementPrototypeFunctionClick(JSC::ExecState*);
+
+// Attributes
+
+JSC::EncodedJSValue jsHTMLElementTitle(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementTitle(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementLang(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementLang(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementTranslate(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementTranslate(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementDir(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementDir(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementTabIndex(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementTabIndex(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementDraggable(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementDraggable(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementWebkitdropzone(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementWebkitdropzone(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementHidden(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementHidden(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementAccessKey(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementAccessKey(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementInnerText(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementInnerText(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementInnerHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName); 
+void setJSHTMLElementInnerHTML(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementOuterText(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementOuterText(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementContentEditable(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementContentEditable(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementIsContentEditable(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsHTMLElementSpellcheck(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementSpellcheck(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsHTMLElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSHTMLElementConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+
+class JSHTMLElementPrototype : public JSC::JSNonFinalObject {
+public:
+    typedef JSC::JSNonFinalObject Base;
+    static JSHTMLElementPrototype* create(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
+    {
+        JSHTMLElementPrototype* ptr = new (NotNull, JSC::allocateCell<JSHTMLElementPrototype>(vm.heap)) JSHTMLElementPrototype(vm, globalObject, structure);
+        ptr->finishCreation(vm);
+        return ptr;
+    }
+
+    DECLARE_INFO;
+    static JSC::Structure* createStructure(JSC::VM& vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
+    {
+        return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
+    }
+
+private:
+    JSHTMLElementPrototype(JSC::VM& vm, JSC::JSGlobalObject*, JSC::Structure* structure)
+        : JSC::JSNonFinalObject(vm, structure)
+    {
+    }
+
+    void finishCreation(JSC::VM&);
+};
+
+typedef JSDOMConstructorNotConstructable<JSHTMLElement> JSHTMLElementConstructor;
+
+template<> JSValue JSHTMLElementConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
+{
+    return JSElement::getConstructor(vm, &globalObject);
+}
+
+template<> void JSHTMLElementConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
+{
+    putDirect(vm, vm.propertyNames->prototype, JSHTMLElement::getPrototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
+    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("HTMLElement"))), ReadOnly | DontEnum);
+    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
+}
+
+template<> const ClassInfo JSHTMLElementConstructor::s_info = { "HTMLElement", &Base::s_info, 0, CREATE_METHOD_TABLE(JSHTMLElementConstructor) };
+
+/* Hash table for prototype */
+
+static const HashTableValue JSHTMLElementPrototypeTableValues[] =
+{
+    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementConstructor) } },
+    { "title", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementTitle), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementTitle) } },
+    { "lang", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementLang), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementLang) } },
+    { "translate", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementTranslate), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementTranslate) } },
+    { "dir", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementDir), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementDir) } },
+    { "tabIndex", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementTabIndex), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementTabIndex) } },
+    { "draggable", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementDraggable), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementDraggable) } },
+    { "webkitdropzone", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementWebkitdropzone), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementWebkitdropzone) } },
+    { "hidden", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementHidden), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementHidden) } },
+    { "accessKey", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementAccessKey), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementAccessKey) } },
+    { "innerText", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementInnerText), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementInnerText) } },
+    { "innerHTML", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementInnerHTML), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementInnerHTML) } },
+    { "outerText", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementOuterText), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementOuterText) } },
+    { "contentEditable", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementContentEditable), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementContentEditable) } },
+    { "isContentEditable", ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementIsContentEditable), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "spellcheck", CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsHTMLElementSpellcheck), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSHTMLElementSpellcheck) } },
+    { "insertAdjacentElement", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLElementPrototypeFunctionInsertAdjacentElement), (intptr_t) (0) } },
+    { "insertAdjacentHTML", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLElementPrototypeFunctionInsertAdjacentHTML), (intptr_t) (0) } },
+    { "insertAdjacentText", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLElementPrototypeFunctionInsertAdjacentText), (intptr_t) (0) } },
+    { "click", JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsHTMLElementPrototypeFunctionClick), (intptr_t) (0) } },
+};
+
+const ClassInfo JSHTMLElementPrototype::s_info = { "HTMLElementPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSHTMLElementPrototype) };
+
+void JSHTMLElementPrototype::finishCreation(VM& vm)
+{
+    Base::finishCreation(vm);
+    reifyStaticProperties(vm, JSHTMLElementPrototypeTableValues, *this);
+}
+
+const ClassInfo JSHTMLElement::s_info = { "HTMLElement", &Base::s_info, 0, CREATE_METHOD_TABLE(JSHTMLElement) };
+
+JSHTMLElement::JSHTMLElement(Structure* structure, JSDOMGlobalObject& globalObject, Ref<HTMLElement>&& impl)
+    : JSElement(structure, globalObject, WTFMove(impl))
+{
+}
+
+JSObject* JSHTMLElement::createPrototype(VM& vm, JSGlobalObject* globalObject)
+{
+    return JSHTMLElementPrototype::create(vm, globalObject, JSHTMLElementPrototype::createStructure(vm, globalObject, JSElement::getPrototype(vm, globalObject)));
+}
+
+JSObject* JSHTMLElement::getPrototype(VM& vm, JSGlobalObject* globalObject)
+{
+    return getDOMPrototype<JSHTMLElement>(vm, globalObject);
+}
+
+EncodedJSValue jsHTMLElementTitle(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "title");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.fastGetAttribute(WebCore::HTMLNames::titleAttr));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementLang(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "lang");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.fastGetAttribute(WebCore::HTMLNames::langAttr));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementTranslate(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "translate");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.translate());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementDir(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "dir");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.dir());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementTabIndex(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "tabIndex");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsNumber(impl.tabIndex());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementDraggable(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "draggable");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.draggable());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementWebkitdropzone(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "webkitdropzone");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.fastGetAttribute(WebCore::HTMLNames::webkitdropzoneAttr));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementHidden(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "hidden");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.fastHasAttribute(WebCore::HTMLNames::hiddenAttr));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementAccessKey(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "accessKey");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.fastGetAttribute(WebCore::HTMLNames::accesskeyAttr));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementInnerText(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "innerText");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.innerText());
+    return JSValue::encode(result);
+}
+
+EncodedJSValue jsHTMLElementInnerHTML(ExecState* state, EncodedJSValue thisValue, PropertyName)                                {
+  UNUSED_PARAM(state);                                                                                                           UNUSED_PARAM(thisValue);
+  JSValue decodedThisValue = JSValue::decode(thisValue);                                                                         auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+  if (UNLIKELY(!castedThis)) {                                                                                                       return throwGetterTypeError(*state, "HTMLElement", "innerHTML");                                                           }                                                                                                                              auto& impl = castedThis->wrapped();
+  JSValue result = jsStringWithCache(state, impl.innerHTML());                                                                   return JSValue::encode(result);
+}
+
+EncodedJSValue jsHTMLElementOuterText(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "outerText");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.outerText());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementContentEditable(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "contentEditable");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.contentEditable());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementIsContentEditable(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "isContentEditable");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.isContentEditable());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementSpellcheck(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSHTMLElement*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "HTMLElement", "spellcheck");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsBoolean(impl.spellcheck());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsHTMLElementConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    JSHTMLElementPrototype* domObject = jsDynamicCast<JSHTMLElementPrototype*>(JSValue::decode(thisValue));
+    if (!domObject)
+        return throwVMTypeError(state);
+    return JSValue::encode(JSHTMLElement::getConstructor(state->vm(), domObject->globalObject()));
+}
+
+
+void setJSHTMLElementConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    JSHTMLElementPrototype* domObject = jsDynamicCast<JSHTMLElementPrototype*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!domObject)) {
+        throwVMTypeError(state);
+        return;
+    }
+    // Shadowing a built-in constructor
+    domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
+}
+
+void setJSHTMLElementTitle(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "title");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::titleAttr, nativeValue);
+}
+
+
+void setJSHTMLElementLang(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "lang");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::langAttr, nativeValue);
+}
+
+
+void setJSHTMLElementTranslate(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "translate");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    bool nativeValue = value.toBoolean(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setTranslate(nativeValue);
+}
+
+
+void setJSHTMLElementDir(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "dir");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setDir(nativeValue);
+}
+
+
+void setJSHTMLElementTabIndex(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "tabIndex");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    int nativeValue = toInt32(state, value, NormalConversion);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setTabIndex(nativeValue);
+}
+
+
+void setJSHTMLElementDraggable(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "draggable");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    bool nativeValue = value.toBoolean(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setDraggable(nativeValue);
+}
+
+
+void setJSHTMLElementWebkitdropzone(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "webkitdropzone");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::webkitdropzoneAttr, nativeValue);
+}
+
+
+void setJSHTMLElementHidden(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "hidden");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    bool nativeValue = value.toBoolean(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setBooleanAttribute(WebCore::HTMLNames::hiddenAttr, nativeValue);
+}
+
+
+void setJSHTMLElementAccessKey(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "accessKey");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setAttributeWithoutSynchronization(WebCore::HTMLNames::accesskeyAttr, nativeValue);
+}
+
+
+void setJSHTMLElementInnerText(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "innerText");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setInnerText(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+void setJSHTMLElementInnerHTML(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+  JSValue value = JSValue::decode(encodedValue);
+  UNUSED_PARAM(thisValue);
+  JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+  if (UNLIKELY(!castedThis)) {
+    throwSetterTypeError(*state, "HTMLElement", "innerHTML");
+    return;
+  }
+  auto& impl = castedThis->wrapped();
+  ExceptionCode ec = 0;
+  String nativeValue = valueToStringWithNullCheck(state, value);
+  if (UNLIKELY(state->hadException()))
+    return;
+  impl.setInnerHTML(nativeValue, ec);
+
+  if(cTaintLog::isDOM_XSS()) {
+    JSString* strPtr = value.toString(state);
+    unsigned int id = rand();
+    cTaintLog::add_taint_log(strPtr->__dxx_source(state), "element.innerHTML", strPtr->__dxx_taint(state), id, 0, true);
+  }
+
+  setDOMException(state, ec);
+}
+
+void setJSHTMLElementOuterText(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "outerText");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setOuterText(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSHTMLElementContentEditable(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "contentEditable");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String nativeValue = valueToStringWithNullCheck(state, value);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setContentEditable(nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSHTMLElementSpellcheck(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSHTMLElement* castedThis = jsDynamicCast<JSHTMLElement*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "HTMLElement", "spellcheck");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    bool nativeValue = value.toBoolean(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setSpellcheck(nativeValue);
+}
+
+
+JSValue JSHTMLElement::getConstructor(VM& vm, const JSGlobalObject* globalObject)
+{
+    return getDOMConstructor<JSHTMLElementConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
+}
+
+EncodedJSValue JSC_HOST_CALL jsHTMLElementPrototypeFunctionInsertAdjacentElement(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDynamicCast<JSHTMLElement*>(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "HTMLElement", "insertAdjacentElement");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSHTMLElement::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String where = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    Element* element = JSElement::toWrapped(state->argument(1));
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.insertAdjacentElement(where, element, ec)));
+
+    setDOMException(state, ec);
+    return JSValue::encode(result);
+}
+
+EncodedJSValue JSC_HOST_CALL jsHTMLElementPrototypeFunctionInsertAdjacentHTML(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDynamicCast<JSHTMLElement*>(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "HTMLElement", "insertAdjacentHTML");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSHTMLElement::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String where = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String html = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.insertAdjacentHTML(where, html, ec);
+    setDOMException(state, ec);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsHTMLElementPrototypeFunctionInsertAdjacentText(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDynamicCast<JSHTMLElement*>(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "HTMLElement", "insertAdjacentText");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSHTMLElement::info());
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String where = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    String text = state->argument(1).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.insertAdjacentText(where, text, ec);
+    setDOMException(state, ec);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsHTMLElementPrototypeFunctionClick(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDynamicCast<JSHTMLElement*>(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "HTMLElement", "click");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSHTMLElement::info());
+    auto& impl = castedThis->wrapped();
+    impl.click();
+    return JSValue::encode(jsUndefined());
+}
+
+void JSHTMLElement::visitChildren(JSCell* cell, SlotVisitor& visitor)
+{
+    auto* thisObject = jsCast<JSHTMLElement*>(cell);
+    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
+    Base::visitChildren(thisObject, visitor);
+    thisObject->wrapped().visitJSEventListeners(visitor);
+}
+
+HTMLElement* JSHTMLElement::toWrapped(JSC::JSValue value)
+{
+    if (auto* wrapper = jsDynamicCast<JSHTMLElement*>(value))
+        return &wrapper->wrapped();
+    return nullptr;
+}
+
+}
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/dom_generated/JSLocation.cpp qtwebkit/Source/WebCore/dom_generated/JSLocation.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/dom_generated/JSLocation.cpp	1969-12-31 16:00:00.000000000 -0800
+++ qtwebkit/Source/WebCore/dom_generated/JSLocation.cpp	2018-04-30 14:47:23.452799000 -0700
@@ -0,0 +1,717 @@
+/*
+    This file is part of the WebKit open source project.
+    This file has been generated by generate-bindings.pl. DO NOT MODIFY!
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "config.h"
+#include "JSLocation.h"
+
+#include "DOMStringList.h"
+#include "ExceptionCode.h"
+#include "JSDOMBinding.h"
+#include "JSDOMConstructor.h"
+#include "JSDOMStringList.h"
+#include "URL.h"
+#include <runtime/Error.h>
+#include <runtime/FunctionPrototype.h>
+#include <runtime/JSString.h>
+#include <wtf/GetPtr.h>
+
+using namespace JSC;
+
+namespace WebCore {
+
+// Functions
+
+JSC::EncodedJSValue JSC_HOST_CALL jsLocationInstanceFunctionToString(JSC::ExecState*);
+
+// Attributes
+
+JSC::EncodedJSValue jsLocationHref(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSLocationHref(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsLocationProtocol(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSLocationProtocol(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsLocationHost(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSLocationHost(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsLocationHostname(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSLocationHostname(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsLocationPort(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSLocationPort(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsLocationPathname(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSLocationPathname(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsLocationSearch(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSLocationSearch(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsLocationHash(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSLocationHash(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+JSC::EncodedJSValue jsLocationOrigin(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsLocationAncestorOrigins(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+JSC::EncodedJSValue jsLocationConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::PropertyName);
+void setJSLocationConstructor(JSC::ExecState*, JSC::EncodedJSValue, JSC::EncodedJSValue);
+
+typedef JSDOMConstructorNotConstructable<JSLocation> JSLocationConstructor;
+
+/* Hash table */
+
+static const struct CompactHashIndex JSLocationTableIndex[35] = {
+    { -1, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { 8, 34 },
+    { -1, -1 },
+    { -1, -1 },
+    { 7, -1 },
+    { 0, 32 },
+    { 5, 33 },
+    { -1, -1 },
+    { 10, -1 },
+    { -1, -1 },
+    { 9, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { 3, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { 11, -1 },
+    { -1, -1 },
+    { 1, -1 },
+    { -1, -1 },
+    { 4, -1 },
+    { 13, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { -1, -1 },
+    { 2, -1 },
+    { 6, -1 },
+    { 12, -1 },
+};
+
+
+static const HashTableValue JSLocationTableValues[] =
+{
+    { "href", DontDelete | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationHref), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSLocationHref) } },
+    { "protocol", DontDelete | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationProtocol), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSLocationProtocol) } },
+    { "host", DontDelete | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationHost), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSLocationHost) } },
+    { "hostname", DontDelete | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationHostname), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSLocationHostname) } },
+    { "port", DontDelete | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationPort), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSLocationPort) } },
+    { "pathname", DontDelete | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationPathname), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSLocationPathname) } },
+    { "search", DontDelete | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationSearch), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSLocationSearch) } },
+    { "hash", DontDelete | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationHash), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSLocationHash) } },
+    { "origin", DontDelete | ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationOrigin), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "ancestorOrigins", DontDelete | ReadOnly | CustomAccessor, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationAncestorOrigins), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(0) } },
+    { "assign", DontDelete | ReadOnly | JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsLocationInstanceFunctionAssign), (intptr_t) (1) } },
+    { "replace", DontDelete | ReadOnly | JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsLocationInstanceFunctionReplace), (intptr_t) (1) } },
+    { "reload", DontDelete | ReadOnly | JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsLocationInstanceFunctionReload), (intptr_t) (0) } },
+    { "toString", DontDelete | ReadOnly | DontEnum | JSC::Function, NoIntrinsic, { (intptr_t)static_cast<NativeFunction>(jsLocationInstanceFunctionToString), (intptr_t) (0) } },
+};
+
+static const HashTable JSLocationTable = { 14, 31, true, JSLocationTableValues, JSLocationTableIndex };
+template<> JSValue JSLocationConstructor::prototypeForStructure(JSC::VM& vm, const JSDOMGlobalObject& globalObject)
+{
+    UNUSED_PARAM(vm);
+    return globalObject.functionPrototype();
+}
+
+template<> void JSLocationConstructor::initializeProperties(VM& vm, JSDOMGlobalObject& globalObject)
+{
+    putDirect(vm, vm.propertyNames->prototype, JSLocation::getPrototype(vm, &globalObject), DontDelete | ReadOnly | DontEnum);
+    putDirect(vm, vm.propertyNames->name, jsNontrivialString(&vm, String(ASCIILiteral("Location"))), ReadOnly | DontEnum);
+    putDirect(vm, vm.propertyNames->length, jsNumber(0), ReadOnly | DontEnum);
+}
+
+template<> const ClassInfo JSLocationConstructor::s_info = { "Location", &Base::s_info, 0, CREATE_METHOD_TABLE(JSLocationConstructor) };
+
+/* Hash table for prototype */
+
+static const HashTableValue JSLocationPrototypeTableValues[] =
+{
+    { "constructor", DontEnum, NoIntrinsic, { (intptr_t)static_cast<PropertySlot::GetValueFunc>(jsLocationConstructor), (intptr_t) static_cast<PutPropertySlot::PutValueFunc>(setJSLocationConstructor) } },
+};
+
+const ClassInfo JSLocationPrototype::s_info = { "LocationPrototype", &Base::s_info, 0, CREATE_METHOD_TABLE(JSLocationPrototype) };
+
+void JSLocationPrototype::finishCreation(VM& vm)
+{
+    Base::finishCreation(vm);
+    reifyStaticProperties(vm, JSLocationPrototypeTableValues, *this);
+}
+
+void JSLocationPrototype::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
+{
+    auto* thisObject = jsCast<JSLocationPrototype*>(cell);
+    if (thisObject->putDelegate(state, propertyName, value, slot))
+        return;
+    Base::put(thisObject, state, propertyName, value, slot);
+}
+
+const ClassInfo JSLocation::s_info = { "Location", &Base::s_info, &JSLocationTable, CREATE_METHOD_TABLE(JSLocation) };
+
+JSLocation::JSLocation(Structure* structure, JSDOMGlobalObject& globalObject, Ref<Location>&& impl)
+    : JSDOMWrapper<Location>(structure, globalObject, WTFMove(impl))
+{
+}
+
+JSObject* JSLocation::createPrototype(VM& vm, JSGlobalObject* globalObject)
+{
+    return JSLocationPrototype::create(vm, globalObject, JSLocationPrototype::createStructure(vm, globalObject, globalObject->objectPrototype()));
+}
+
+JSObject* JSLocation::getPrototype(VM& vm, JSGlobalObject* globalObject)
+{
+    return getDOMPrototype<JSLocation>(vm, globalObject);
+}
+
+void JSLocation::destroy(JSC::JSCell* cell)
+{
+    JSLocation* thisObject = static_cast<JSLocation*>(cell);
+    thisObject->JSLocation::~JSLocation();
+}
+
+bool JSLocation::getOwnPropertySlot(JSObject* object, ExecState* state, PropertyName propertyName, PropertySlot& slot)
+{
+    auto* thisObject = jsCast<JSLocation*>(object);
+    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
+    if (thisObject->getOwnPropertySlotDelegate(state, propertyName, slot))
+        return true;
+    if (getStaticPropertySlot<JSLocation, Base>(state, JSLocationTable, thisObject, propertyName, slot))
+        return true;
+    return false;
+}
+
+bool JSLocation::getOwnPropertySlotByIndex(JSObject* object, ExecState* state, unsigned index, PropertySlot& slot)
+{
+    auto* thisObject = jsCast<JSLocation*>(object);
+    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
+    Identifier propertyName = Identifier::from(state, index);
+    if (thisObject->getOwnPropertySlotDelegate(state, propertyName, slot))
+        return true;
+    return Base::getOwnPropertySlotByIndex(thisObject, state, index, slot);
+}
+
+EncodedJSValue jsLocationHref(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "href");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.href());
+
+    //DOM_XSS
+    if(cTaintLog::isDOM_XSS_Exploit())
+    { 
+      //std::cout<< "inside location.href.getter()   " << result.toString(exec)->value(exec).utf8().data() << std::endl;
+      String str=decodeURLEscapeSequences(result.toString(state)->value(state));
+      JSValue ret  = jsStringWithCache(state, str);
+      //std::cout<< "location.href.getter()   " << str.utf8().data() << std::endl;
+      return JSValue::encode(ret);
+    }
+
+    if(cTaintLog::isDOM_XSS()) {
+      JSString* strPtr = result.toString(state);
+      strPtr->__dxx_taint(state)=100;
+      strPtr->__dxx_source(state)=eSourceTypeLocation;
+      //std::cout<< "inside location.href.getter() We have set the taint to " << result.toString(exec)->taint(exec) << std::endl;
+    }
+
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationProtocol(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "protocol");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.protocol());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationHost(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "host");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.host());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationHostname(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "hostname");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.hostname());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationPort(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "port");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.port());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationPathname(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "pathname");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.pathname());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationSearch(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "search");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.search());
+    //DOM_XSS
+    if(cTaintLog::isDOM_XSS_Exploit())
+    { 
+      String str=decodeURLEscapeSequences(result.toString(state)->value(state));
+      JSValue ret  = jsStringWithCache(state, str);
+      //std::cout<< "location.hash.getter()   " << str.utf8().data() << std::endl;
+      return JSValue::encode(ret);
+    }
+
+    if(cTaintLog::isDOM_XSS()) {
+      JSString* strPtr = result.toString(state);
+      strPtr->__dxx_taint(state)=100;
+      strPtr->__dxx_source(state)=eSourceTypeLocation;
+      //std::cout<< "inside location.hash.getter() We have set the taint to " << result.toString(exec)->taint(exec) << std::endl;
+    }
+
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationHash(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "hash");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.hash());
+
+    //DOM_XSS
+    if(cTaintLog::isDOM_XSS_Exploit())
+    {
+      //std::cout<< "inside location.hash.getter()   " << result.toString(exec)->value(exec).utf8().data() << std::endl;
+      String str=decodeURLEscapeSequences(result.toString(state)->value(state));
+      JSValue ret  = jsStringWithCache(state, str);
+      //std::cout<< "location.hash.getter()   " << str.utf8().data() << std::endl;
+      return JSValue::encode(ret);
+    }
+
+    if(cTaintLog::isDOM_XSS()) {
+      JSString* strPtr = result.toString(state);
+      strPtr->__dxx_taint(state)=100;
+      strPtr->__dxx_source(state)=eSourceTypeLocation;
+      //std::cout<< "inside location.hash.getter() We have set the taint to " << result.toString(exec)->taint(exec) << std::endl;
+    }
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationOrigin(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "origin");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = jsStringWithCache(state, impl.origin());
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationAncestorOrigins(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    UNUSED_PARAM(state);
+    UNUSED_PARAM(thisValue);
+    JSValue decodedThisValue = JSValue::decode(thisValue);
+    auto* castedThis = jsDynamicCast<JSLocation*>(decodedThisValue);
+    if (UNLIKELY(!castedThis)) {
+        return throwGetterTypeError(*state, "Location", "ancestorOrigins");
+    }
+    auto& impl = castedThis->wrapped();
+    JSValue result = toJS(state, castedThis->globalObject(), WTF::getPtr(impl.ancestorOrigins()));
+    return JSValue::encode(result);
+}
+
+
+EncodedJSValue jsLocationConstructor(ExecState* state, EncodedJSValue thisValue, PropertyName)
+{
+    JSLocationPrototype* domObject = jsDynamicCast<JSLocationPrototype*>(JSValue::decode(thisValue));
+    if (!domObject)
+        return throwVMTypeError(state);
+    return JSValue::encode(JSLocation::getConstructor(state->vm(), domObject->globalObject()));
+}
+
+void setJSLocationConstructor(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    JSLocationPrototype* domObject = jsDynamicCast<JSLocationPrototype*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!domObject)) {
+        throwVMTypeError(state);
+        return;
+    }
+    // Shadowing a built-in constructor
+    domObject->putDirect(state->vm(), state->propertyNames().constructor, value);
+}
+
+void JSLocation::put(JSCell* cell, ExecState* state, PropertyName propertyName, JSValue value, PutPropertySlot& slot)
+{
+    auto* thisObject = jsCast<JSLocation*>(cell);
+    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
+    if (thisObject->putDelegate(state, propertyName, value, slot))
+        return;
+    Base::put(thisObject, state, propertyName, value, slot);
+}
+
+void JSLocation::putByIndex(JSCell* cell, ExecState* state, unsigned index, JSValue value, bool shouldThrow)
+{
+    auto* thisObject = jsCast<JSLocation*>(cell);
+    ASSERT_GC_OBJECT_INHERITS(thisObject, info());
+    Identifier propertyName = Identifier::from(state, index);
+    PutPropertySlot slot(thisObject, shouldThrow);
+    if (thisObject->putDelegate(state, propertyName, value, slot))
+        return;
+    Base::putByIndex(cell, state, index, value, shouldThrow);
+}
+
+void setJSLocationHref(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSLocation* castedThis = jsDynamicCast<JSLocation*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Location", "href");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setHref(activeDOMWindow(state), firstDOMWindow(state), nativeValue);
+}
+
+
+void setJSLocationProtocol(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSLocation* castedThis = jsDynamicCast<JSLocation*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Location", "protocol");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    ExceptionCode ec = 0;
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setProtocol(activeDOMWindow(state), firstDOMWindow(state), nativeValue, ec);
+    setDOMException(state, ec);
+}
+
+
+void setJSLocationHost(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSLocation* castedThis = jsDynamicCast<JSLocation*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Location", "host");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setHost(activeDOMWindow(state), firstDOMWindow(state), nativeValue);
+}
+
+
+void setJSLocationHostname(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSLocation* castedThis = jsDynamicCast<JSLocation*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Location", "hostname");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setHostname(activeDOMWindow(state), firstDOMWindow(state), nativeValue);
+}
+
+
+void setJSLocationPort(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSLocation* castedThis = jsDynamicCast<JSLocation*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Location", "port");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setPort(activeDOMWindow(state), firstDOMWindow(state), nativeValue);
+}
+
+
+void setJSLocationPathname(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSLocation* castedThis = jsDynamicCast<JSLocation*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Location", "pathname");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setPathname(activeDOMWindow(state), firstDOMWindow(state), nativeValue);
+}
+
+
+void setJSLocationSearch(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSLocation* castedThis = jsDynamicCast<JSLocation*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Location", "search");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setSearch(activeDOMWindow(state), firstDOMWindow(state), nativeValue);
+}
+
+
+void setJSLocationHash(ExecState* state, EncodedJSValue thisValue, EncodedJSValue encodedValue)
+{
+    JSValue value = JSValue::decode(encodedValue);
+    UNUSED_PARAM(thisValue);
+    JSLocation* castedThis = jsDynamicCast<JSLocation*>(JSValue::decode(thisValue));
+    if (UNLIKELY(!castedThis)) {
+        throwSetterTypeError(*state, "Location", "hash");
+        return;
+    }
+    auto& impl = castedThis->wrapped();
+    String nativeValue = value.toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return;
+    impl.setHash(activeDOMWindow(state), firstDOMWindow(state), nativeValue);
+}
+
+
+JSValue JSLocation::getConstructor(VM& vm, const JSGlobalObject* globalObject)
+{
+    return getDOMConstructor<JSLocationConstructor>(vm, *jsCast<const JSDOMGlobalObject*>(globalObject));
+}
+
+EncodedJSValue JSC_HOST_CALL jsLocationInstanceFunctionAssign(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDynamicCast<JSLocation*>(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Location", "assign");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSLocation::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    String url = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.assign(activeDOMWindow(state), firstDOMWindow(state), url);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsLocationInstanceFunctionReplace(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDynamicCast<JSLocation*>(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Location", "replace");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSLocation::info());
+    auto& impl = castedThis->wrapped();
+    if (UNLIKELY(state->argumentCount() < 1))
+        return throwVMError(state, createNotEnoughArgumentsError(state));
+    String url = state->argument(0).toString(state)->value(state);
+    if (UNLIKELY(state->hadException()))
+        return JSValue::encode(jsUndefined());
+    impl.replace(activeDOMWindow(state), firstDOMWindow(state), url);
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsLocationInstanceFunctionReload(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDynamicCast<JSLocation*>(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Location", "reload");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSLocation::info());
+    auto& impl = castedThis->wrapped();
+    impl.reload(activeDOMWindow(state));
+    return JSValue::encode(jsUndefined());
+}
+
+EncodedJSValue JSC_HOST_CALL jsLocationInstanceFunctionToString(ExecState* state)
+{
+    JSValue thisValue = state->thisValue();
+    auto castedThis = jsDynamicCast<JSLocation*>(thisValue);
+    if (UNLIKELY(!castedThis))
+        return throwThisTypeError(*state, "Location", "toString");
+    ASSERT_GC_OBJECT_INHERITS(castedThis, JSLocation::info());
+    return JSValue::encode(castedThis->toStringFunction(*state));
+}
+
+bool JSLocationOwner::isReachableFromOpaqueRoots(JSC::Handle<JSC::Unknown> handle, void*, SlotVisitor& visitor)
+{
+    auto* jsLocation = jsCast<JSLocation*>(handle.slot()->asCell());
+    Frame* root = WTF::getPtr(jsLocation->wrapped().frame());
+    if (!root)
+        return false;
+    return visitor.containsOpaqueRoot(root);
+}
+
+void JSLocationOwner::finalize(JSC::Handle<JSC::Unknown> handle, void* context)
+{
+    auto* jsLocation = jsCast<JSLocation*>(handle.slot()->asCell());
+    auto& world = *static_cast<DOMWrapperWorld*>(context);
+    uncacheWrapper(world, &jsLocation->wrapped(), jsLocation);
+}
+
+#if ENABLE(BINDING_INTEGRITY)
+#if PLATFORM(WIN)
+#pragma warning(disable: 4483)
+extern "C" { extern void (*const __identifier("??_7Location@WebCore@@6B@")[])(); }
+#else
+extern "C" { extern void* _ZTVN7WebCore8LocationE[]; }
+#endif
+#endif
+
+JSC::JSValue toJSNewlyCreated(JSC::ExecState*, JSDOMGlobalObject* globalObject, Location* impl)
+{
+    if (!impl)
+        return jsNull();
+    return createNewWrapper<JSLocation>(globalObject, impl);
+}
+
+JSC::JSValue toJS(JSC::ExecState*, JSDOMGlobalObject* globalObject, Location* impl)
+{
+    if (!impl)
+        return jsNull();
+    if (JSValue result = getExistingWrapper<JSLocation>(globalObject, impl))
+        return result;
+
+#if ENABLE(BINDING_INTEGRITY)
+    void* actualVTablePointer = *(reinterpret_cast<void**>(impl));
+#if PLATFORM(WIN)
+    void* expectedVTablePointer = reinterpret_cast<void*>(__identifier("??_7Location@WebCore@@6B@"));
+#else
+    void* expectedVTablePointer = &_ZTVN7WebCore8LocationE[2];
+#if COMPILER(CLANG)
+    // If this fails Location does not have a vtable, so you need to add the
+    // ImplementationLacksVTable attribute to the interface definition
+    COMPILE_ASSERT(__is_polymorphic(Location), Location_is_not_polymorphic);
+#endif
+#endif
+    // If you hit this assertion you either have a use after free bug, or
+    // Location has subclasses. If Location has subclasses that get passed
+    // to toJS() we currently require Location you to opt out of binding hardening
+    // by adding the SkipVTableValidation attribute to the interface IDL definition
+    RELEASE_ASSERT(actualVTablePointer == expectedVTablePointer);
+#endif
+    return createNewWrapper<JSLocation>(globalObject, impl);
+}
+
+Location* JSLocation::toWrapped(JSC::JSValue value)
+{
+    if (auto* wrapper = jsDynamicCast<JSLocation*>(value))
+        return &wrapper->wrapped();
+    return nullptr;
+}
+
+}
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/loader/CookieJar.cpp qtwebkit/Source/WebCore/loader/CookieJar.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/loader/CookieJar.cpp	2017-06-04 13:16:06.000000000 -0700
+++ qtwebkit/Source/WebCore/loader/CookieJar.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -33,6 +33,8 @@
 #include "NetworkingContext.h"
 #include "PlatformCookieJar.h"
 #include "PlatformStrategies.h"
+#include <iostream>
+#include <API/JSBase.h>
 
 namespace WebCore {
 
@@ -63,6 +65,7 @@
 
 void setCookies(Document* document, const URL& url, const String& cookieString)
 {
+    cTaintLog::log_rcv_cookies(cookieString.ascii().data());
     LOCAL_SESSION(document)
     platformStrategies()->cookiesStrategy()->setCookiesFromDOM(session, document->firstPartyForCookies(), url, cookieString);
 }
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/loader/ResourceLoader.cpp qtwebkit/Source/WebCore/loader/ResourceLoader.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/loader/ResourceLoader.cpp	2017-06-04 13:16:06.000000000 -0700
+++ qtwebkit/Source/WebCore/loader/ResourceLoader.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -51,6 +51,9 @@
 #include "Settings.h"
 #include "SharedBuffer.h"
 #include <wtf/Ref.h>
+#include <iostream>
+#include <sstream>
+#include <API/JSBase.h>
 
 #if ENABLE(CONTENT_EXTENSIONS)
 #include "ResourceLoadInfo.h"
@@ -459,6 +462,9 @@
     // happens with the steps listed in 3266216
     // ASSERT(con == connection);
     // ASSERT(!m_reachedTerminalState);
+    //
+
+    cTaintLog::log_rcv_body(data);
 
     didReceiveDataOrBuffer(data, length, 0, encodedDataLength, dataPayloadType);
 }
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/loader/ResourceLoadNotifier.cpp qtwebkit/Source/WebCore/loader/ResourceLoadNotifier.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/loader/ResourceLoadNotifier.cpp	2017-06-04 13:16:06.000000000 -0700
+++ qtwebkit/Source/WebCore/loader/ResourceLoadNotifier.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -39,6 +39,10 @@
 #include "Page.h"
 #include "ProgressTracker.h"
 #include "ResourceLoader.h"
+#include <iostream>
+#include <sstream>
+#include <API/JSBase.h>
+#include <wtf/text/StringBuilder.h>
 
 #if USE(QUICK_LOOK)
 #include "QuickLook.h"
@@ -83,7 +87,20 @@
     loader->documentLoader()->addResponse(r);
 
     if (Page* page = m_frame.page())
-        page->progress().incrementProgress(loader->identifier(), r);
+      page->progress().incrementProgress(loader->identifier(), r);
+    
+    StringBuilder stringBuilder;
+
+    HTTPHeaderMap::const_iterator end = r.httpHeaderFields().end();
+    for (HTTPHeaderMap::const_iterator it = r.httpHeaderFields().begin(); it!= end; ++it) {
+      stringBuilder.append(it->key); 
+      stringBuilder.append(':');
+      stringBuilder.append(' ');
+      stringBuilder.append(it->value);
+      stringBuilder.append("_CR_LF_");
+    }
+
+    cTaintLog::log_rcv_headers(stringBuilder.toString().ascii().data());
 
     dispatchDidReceiveResponse(loader->documentLoader(), loader->identifier(), r, loader);
 }
@@ -136,6 +153,13 @@
     if (!request.isNull() && oldRequestURL != request.url().string())
         m_frame.loader().documentLoader()->didTellClientAboutLoad(request.url());
 
+    if(!request.isNull()) {
+      if(request.httpBody())
+        cTaintLog::log_sent_body(request.httpBody()->flattenToString().ascii().data());
+      else 
+        cTaintLog::log_sent_body("");
+    }
+
     InspectorInstrumentation::willSendRequest(&m_frame, identifier, loader, request, redirectResponse);
 
     // Report WebTiming for all frames.
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/Modules/geolocation/Geolocation.cpp qtwebkit/Source/WebCore/Modules/geolocation/Geolocation.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/Modules/geolocation/Geolocation.cpp	2017-06-04 13:16:06.000000000 -0700
+++ qtwebkit/Source/WebCore/Modules/geolocation/Geolocation.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -30,6 +30,9 @@
 
 #if ENABLE(GEOLOCATION)
 
+//USE_FAKE_GEOLOCATION: Provide fake geo location for getCurrentPosition
+#define USE_FAKE_GEOLOCATION
+
 #include "Coordinates.h"
 #include "Document.h"
 #include "Frame.h"
@@ -43,6 +46,9 @@
 #include "SecurityOrigin.h"
 #include <wtf/CurrentTime.h>
 #include <wtf/Ref.h>
+#ifdef USE_FAKE_GEOLOCATION
+#include <QDateTime>
+#endif
 
 namespace WebCore {
 
@@ -316,9 +322,19 @@
         return;
 
     RefPtr<GeoNotifier> notifier = GeoNotifier::create(*this, WTFMove(successCallback), WTFMove(errorCallback), WTFMove(options));
+#ifdef USE_FAKE_GEOLOCATION
+    RefPtr<Coordinates> coordinates = Coordinates::create(37.536646, -122.258396, false, 0,
+                                                          2, false, 0,
+                                                          0, 0, false, 0);
+    RefPtr<Geoposition> position = Geoposition::create(coordinates.release(), convertSecondsToDOMTimeStamp(QDateTime::currentMSecsSinceEpoch()/1000.0));
+    m_allowGeolocation = Yes;
+    notifier->runSuccessCallback(position.get());
+    notifier->stopTimer();
+#else
     startRequest(notifier.get());
 
     m_oneShots.add(notifier);
+#endif
 }
 
 int Geolocation::watchPosition(RefPtr<PositionCallback>&& successCallback, RefPtr<PositionErrorCallback>&& errorCallback, RefPtr<PositionOptions>&& options)
@@ -327,7 +343,17 @@
         return 0;
 
     RefPtr<GeoNotifier> notifier = GeoNotifier::create(*this, WTFMove(successCallback), WTFMove(errorCallback), WTFMove(options));
+#ifdef USE_FAKE_GEOLOCATION
+    RefPtr<Coordinates> coordinates = Coordinates::create(37.536646, -122.258396, false, 0,
+                                                          2, false, 0,
+                                                          0, 0, false, 0);
+    RefPtr<Geoposition> position = Geoposition::create(coordinates.release(), convertSecondsToDOMTimeStamp(QDateTime::currentMSecsSinceEpoch()/1000.0));
+    m_allowGeolocation = Yes;
+    notifier->runSuccessCallback(position.get());
+    notifier->stopTimer();
+#else
     startRequest(notifier.get());
+#endif
 
     int watchID;
     // Keep asking for the next id until we're given one that we don't already have.
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/page/csp/ContentSecurityPolicy.cpp qtwebkit/Source/WebCore/page/csp/ContentSecurityPolicy.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/page/csp/ContentSecurityPolicy.cpp	2017-06-09 08:00:40.000000000 -0700
+++ qtwebkit/Source/WebCore/page/csp/ContentSecurityPolicy.cpp	2018-06-11 09:41:39.889252000 -0700
@@ -50,6 +50,11 @@
 #include <inspector/ScriptCallStackFactory.h>
 #include <wtf/text/TextPosition.h>
 
+/*
+ * Disable CSP checks to allow loading of content restricted by CSP checks till latest CSP is supported.
+ */
+#define DISABLE_CSP_CHECKS 1
+
 using namespace Inspector;
 
 namespace WebCore {
@@ -96,6 +101,11 @@
 
 void ContentSecurityPolicy::didReceiveHeader(const String& header, ContentSecurityPolicyHeaderType type, ContentSecurityPolicy::PolicyFrom policyFrom)
 {
+
+#ifdef DISABLE_CSP_CHECKS
+    // Skip processing the CSP headers, effectively disabling CSP.
+    return;
+#endif
     // RFC2616, section 4.2 specifies that headers appearing multiple times can
     // be combined with a comma. Walk the header string, and parse each comma
     // separated chunk as a separate header.
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebCore/platform/network/qt/QNetworkReplyHandler.cpp qtwebkit/Source/WebCore/platform/network/qt/QNetworkReplyHandler.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebCore/platform/network/qt/QNetworkReplyHandler.cpp	2017-06-13 19:26:49.000000000 -0700
+++ qtwebkit/Source/WebCore/platform/network/qt/QNetworkReplyHandler.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -330,13 +330,18 @@
     m_encoding = extractCharsetFromMediaType(contentType);
     m_advertisedMIMEType = extractMIMETypeFromMediaType(contentType);
 
-    m_redirectionTargetUrl = m_reply->attribute(QNetworkRequest::RedirectionTargetAttribute).toUrl();
-    if (m_redirectionTargetUrl.isValid()) {
-        QueueLocker lock(m_queue);
-        m_queue->push(&QNetworkReplyHandler::sendResponseIfNeeded);
-        m_queue->push(&QNetworkReplyHandler::finish);
-        return;
-    }
+    const QVariant &dontFollowRedirect = m_reply->property("X_DONT_FOLLOW_REDIRECT");
+    if (!(dontFollowRedirect.isValid() && (dontFollowRedirect.toBool() == true))) {
+      // Follow redirect only if 'X_DONT_FOLLOW_REDIRECT' property is not set
+      // to true on the reply.
+      m_redirectionTargetUrl = m_reply->attribute(QNetworkRequest::RedirectionTargetAttribute).toUrl();
+      if (m_redirectionTargetUrl.isValid()) {
+          QueueLocker lock(m_queue);
+          m_queue->push(&QNetworkReplyHandler::sendResponseIfNeeded);
+          m_queue->push(&QNetworkReplyHandler::finish);
+          return;
+      }
+    }    
 
     if (!m_sniffMIMETypes) {
         emitMetaDataChanged();
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebKit/qt/Api/qwebelement.cpp qtwebkit/Source/WebKit/qt/Api/qwebelement.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebKit/qt/Api/qwebelement.cpp	2017-06-04 13:16:07.000000000 -0700
+++ qtwebkit/Source/WebKit/qt/Api/qwebelement.cpp	2018-06-28 06:51:17.977206000 -0700
@@ -54,6 +54,10 @@
 #include <JSDocument.h>
 #include <wtf/Vector.h>
 #include <wtf/text/CString.h>
+#include "JSEventListener.h"
+#include "Executable.h"
+#include "JSFunction.h"
+#include "SourceProvider.h"
 
 #include <QPainter>
 
@@ -1472,6 +1476,48 @@
     context.restore();
 }
 
+
+QVector<EventListenersInfoList> QWebElement::getEventListeners() const
+{
+    QVector<EventListenersInfoList> eventListenersInfoVector;
+    if(!m_element) {
+        return eventListenersInfoVector;
+    }
+    Node* ancestor = m_element;
+    EventTargetData* d = ancestor->eventTargetData();
+    if (!d)
+        return eventListenersInfoVector;
+    // Get the list of event types this Node is concerned with
+    Vector<AtomicString> eventTypes = d->eventListenerMap.eventTypes();
+    for (size_t j = 0; j < eventTypes.size(); ++j) {
+        AtomicString& type = eventTypes[j];
+        EventListenersInfoList listenerInfoList(type);
+        const EventListenerVector& vector = ancestor->getEventListeners(type);
+
+        for (size_t j = 0; j < vector.size(); ++j) {
+            const RegisteredEventListener& registeredEventListener = vector[j];
+            RefPtr<EventListener> eventListener = registeredEventListener.listener;
+            listenerInfoList.listenerFunctionList.append(eventListenerHandlerBody(ancestor->document(), eventListener.get()));
+        }
+        eventListenersInfoVector.append(listenerInfoList);
+    }
+    return eventListenersInfoVector;
+}
+
+QString QWebElement::eventListenerHandlerBody(Document &document, EventListener* eventListener) const
+{
+    const JSEventListener* jsListener = JSEventListener::cast(eventListener);
+    ASSERT(jsListener);
+    if (!jsListener)
+        return QString();
+    JSC::JSLockHolder lock(jsListener->isolatedWorld().vm());
+    JSC::JSObject* jsFunction = jsListener->jsFunction(&document);
+    if (!jsFunction)
+        return QString();
+    ScriptState* scriptState = execStateFromNode(jsListener->isolatedWorld(), &document);
+    return jsFunction->toString(scriptState)->value(scriptState);
+}
+
 void QWebElement::beginEnterFullScreen()
 {
 #if ENABLE(FULLSCREEN_API)
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebKit/qt/Api/qwebelement.h qtwebkit/Source/WebKit/qt/Api/qwebelement.h
--- qtwebkit-5.212.0-alpha2/Source/WebKit/qt/Api/qwebelement.h	2017-06-04 13:16:07.000000000 -0700
+++ qtwebkit/Source/WebKit/qt/Api/qwebelement.h	2018-06-28 06:51:17.977206000 -0700
@@ -32,6 +32,8 @@
 class ChromeClientQt;
 class Element;
 class Node;
+class Document;
+class EventListener;
 }
 
 QT_BEGIN_NAMESPACE
@@ -43,6 +45,15 @@
 class QWebElementCollection;
 class QWebElementPrivate;
 
+struct EventListenersInfoList {
+    EventListenersInfoList(QString eventType = QString()):
+        eventType(eventType)
+    {
+    }
+    QString eventType;
+    QStringList listenerFunctionList;
+};
+
 class QWEBKIT_EXPORT QWebElement {
 public:
     QWebElement();
@@ -145,6 +156,7 @@
 
     void render(QPainter* painter);
     void render(QPainter* painter, const QRect& clipRect);
+    QVector<EventListenersInfoList> getEventListeners() const;
 
 private:
     explicit QWebElement(WebCore::Element*);
@@ -154,6 +166,8 @@
     void beginExitFullScreen();
     void endExitFullScreen();
 
+    QString eventListenerHandlerBody(WebCore::Document &document, WebCore::EventListener *eventListener) const;
+
     friend class WebCore::ChromeClientQt;
     friend class DumpRenderTreeSupportQt;
     friend class QWebElementCollection;
diff -Naur qtwebkit-5.212.0-alpha2/Source/WebKit/qt/WebCoreSupport/PlatformStrategiesQt.cpp qtwebkit/Source/WebKit/qt/WebCoreSupport/PlatformStrategiesQt.cpp
--- qtwebkit-5.212.0-alpha2/Source/WebKit/qt/WebCoreSupport/PlatformStrategiesQt.cpp	2017-06-04 13:16:07.000000000 -0700
+++ qtwebkit/Source/WebKit/qt/WebCoreSupport/PlatformStrategiesQt.cpp	2018-09-11 03:53:52.002570000 -0700
@@ -133,6 +133,8 @@
             PluginInfo info;
             info.name = qplugin.name;
             info.desc = qplugin.description;
+            info.isApplicationPlugin = false;
+            info.clientLoadPolicy = WebCore::PluginLoadClientPolicyUndefined;
 
             for (int j = 0; j < qplugin.mimeTypes.count(); ++j) {
                 const QWebPluginFactory::MimeType& mimeType = qplugin.mimeTypes.at(j);
@@ -157,6 +159,8 @@
         info.name = package->name();
         info.file = package->fileName();
         info.desc = package->description();
+        info.isApplicationPlugin = false;
+        info.clientLoadPolicy = WebCore::PluginLoadClientPolicyUndefined;
 
         const auto& mimeToDescriptions = package->mimeToDescriptions();
         for (auto it = mimeToDescriptions.begin(); it != mimeToDescriptions.end(); ++it) {
